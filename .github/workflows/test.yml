name: Release & Deploy OpenWRT Packages

on:
  workflow_dispatch:
    inputs:
      runs_id:
        description: 'Run ID to build packages'
        required: true
        type: string
      force_cleanup:
        description: 'Force repository cleanup'
        required: false
        type: boolean
        default: false

env:
  FORCE_UNSAFE_CONFIGURE: 1
  MAX_REPO_SIZE_GB: 5
  SOURCE_REPO: ${{ github.repository }}

jobs:
  release:
    name: ğŸš€ Release & Deploy Packages
    runs-on: ubuntu-latest

    steps:
      - name: ğŸ¯ Release initialization
        run: |
          echo "::notice title=Release Started::ğŸš€ Starting package release process"
          echo "### ğŸš€ Release Pipeline" >> $GITHUB_STEP_SUMMARY
          echo "- **Trigger**: ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Run ID**: ${{ github.event.inputs.runs_id }}" >> $GITHUB_STEP_SUMMARY

      - name: ğŸ“¥ Checkout releases branch
        uses: actions/checkout@v4
        with:
          ref: releases
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: ğŸ”§ Setup release environment
        run: |
          # Install dependencies
          sudo apt-get update -qq
          sudo apt-get install -y --no-install-recommends jq zstd pv curl
          
          # Configure Git
          git config user.email "actions@github.com"
          git config user.name "ğŸ¤– OpenWRT Package Bot"
          git config pull.rebase true
          git config core.compression 9
          git config pack.compression 9
          
          # Create .gitattributes for better handling of binary files
          cat > .gitattributes <<EOF
          *.ipk binary
          *.apk binary
          *.tar.gz binary
          *.tar.xz binary
          Packages text
          README.md text
          *.json text
          EOF

      - name: â¬‡ï¸ Download artifacts
        uses: actions/download-artifact@v4
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          run-id: ${{ github.event.inputs.runs_id }}
          merge-multiple: true
          path: ./temp-artifacts

      - name: ğŸ“¦ Process artifacts
        id: download
        run: |
          if [ ! -d "./temp-artifacts" ]; then
            echo "::error::No artifacts directory found"
            echo "success=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          echo "ğŸ” Debug: Listing artifact structure..."
          find ./temp-artifacts -type d | head -20
          echo ""
          find ./temp-artifacts -name "*.ipk" -o -name "*.apk" | head -10
          echo ""
          
          total_packages=$(find ./temp-artifacts -name "*.ipk" -o -name "*.apk" 2>/dev/null | wc -l)
          echo "ğŸ“Š Found $total_packages total packages"
          
          if [ $total_packages -eq 0 ]; then
            echo "::warning::No packages found in artifacts"
            echo "success=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "success=true" >> $GITHUB_OUTPUT
          echo "total_packages=$total_packages" >> $GITHUB_OUTPUT
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: ğŸ”„ Process and organize packages
        if: steps.download.outputs.success == 'true'
        run: |
          echo "::group::ğŸ”„ Processing artifacts"
          
          # Debug: List all artifacts first
          echo "ğŸ” Available artifacts:"
          find ./temp-artifacts -type d -name "*packages*" || true
          find ./temp-artifacts -type f -name "*.ipk" -o -name "*.apk" | head -10 || true
          
          mkdir -p packages
          total_processed=0
          
          # Improved architecture detection patterns
          declare -A arch_patterns=(
            ["aarch64_cortex-a53"]="aarch64_cortex-a53"
            ["aarch64_cortex-a72"]="aarch64_cortex-a72" 
            ["aarch64_cortex-a76"]="aarch64_cortex-a76"
            ["aarch64_generic"]="aarch64_generic"
            ["x86_64"]="x86_64"
          )
          
          declare -A branch_patterns=(
            ["23.05"]="23.05"
            ["24.10"]="24.10"
            ["SNAPSHOT"]="SNAPSHOT"
            ["snapshot"]="SNAPSHOT"
            ["openwrt-23.05"]="23.05"
            ["openwrt-24.10"]="24.10"
          )
          
          # Function to detect architecture from path
          detect_arch() {
            local path="$1"
            for pattern in "${!arch_patterns[@]}"; do
              if echo "$path" | grep -q "$pattern"; then
                echo "${arch_patterns[$pattern]}"
                return 0
              fi
            done
            # Fallback: try to extract from path components
            local parts=($(echo "$path" | tr '/' '\n'))
            for part in "${parts[@]}"; do
              if [[ "$part" =~ ^(aarch64|arm|mips|x86).*$ ]]; then
                echo "$part"
                return 0
              fi
            done
            echo "unknown"
          }
          
          # Function to detect branch from path  
          detect_branch() {
            local path="$1"
            for pattern in "${!branch_patterns[@]}"; do
              if echo "$path" | grep -q "$pattern"; then
                echo "${branch_patterns[$pattern]}"
                return 0
              fi
            done
            echo "SNAPSHOT"
          }
          
          # Search for packages and organize them properly
          find ./temp-artifacts -name "*.ipk" -o -name "*.apk" 2>/dev/null | while IFS= read -r package_file; do
            if [ ! -f "$package_file" ]; then
              continue
            fi
            
            # Extract directory info from path
            package_dir=$(dirname "$package_file")
            relative_path=${package_dir#./temp-artifacts/}
            
            echo "ğŸ“„ Processing package: $(basename "$package_file")"
            echo "  ğŸ“ From directory: $relative_path"
            
            # Detect architecture and branch
            arch=$(detect_arch "$relative_path")
            branch=$(detect_branch "$relative_path")
            
            # Handle artifact naming patterns like "packages_arch-branch" 
            if echo "$relative_path" | grep -q "packages_"; then
              artifact_name=$(echo "$relative_path" | grep -o "packages_[^/]*" | head -1)
              if [ -n "$artifact_name" ]; then
                metadata=${artifact_name#packages_}
                # Try to split by dash to get arch-branch pattern
                if [[ "$metadata" =~ ^(.+)-(.+)$ ]]; then
                  potential_arch="${BASH_REMATCH[1]}"
                  potential_branch="${BASH_REMATCH[2]}"
                  
                  # Validate detected components
                  for known_arch in "${!arch_patterns[@]}"; do
                    if [ "$potential_arch" = "$known_arch" ]; then
                      arch="$potential_arch"
                      break
                    fi
                  done
                  
                  for known_branch in "${!branch_patterns[@]}"; do
                    if [ "$potential_branch" = "$known_branch" ]; then
                      branch="${branch_patterns[$potential_branch]}"
                      break
                    fi
                  done
                fi
              fi
            fi
            
            echo "  ğŸ—ï¸ Detected Architecture: $arch"
            echo "  ğŸŒ¿ Detected Branch: $branch"
            
            # Create proper directory structure: packages/branch/arch
            target_dir="packages/$branch/$arch"
            mkdir -p "$target_dir"
            
            # Copy package to target directory
            package_name=$(basename "$package_file")
            if cp "$package_file" "$target_dir/"; then
              echo "  âœ… Copied: $package_name â†’ $target_dir/"
              total_processed=$((total_processed + 1))
            else
              echo "  âŒ Failed to copy: $package_name"
            fi
          done
          
          # Copy metadata files (Packages, Packages.gz, etc.)
          echo "ğŸ” Processing metadata files..."
          find ./temp-artifacts -name "Packages" -o -name "Packages.gz" -o -name "Packages.xz" 2>/dev/null | while IFS= read -r meta_file; do
            if [ -f "$meta_file" ]; then
              meta_dir=$(dirname "$meta_file")
              relative_path=${meta_dir#./temp-artifacts/}
              
              echo "ğŸ“‹ Found metadata: $(basename "$meta_file")"
              echo "  ğŸ“ From: $relative_path"
              
              # Try to match metadata to the correct package directory
              arch=$(detect_arch "$relative_path")
              branch=$(detect_branch "$relative_path")
              
              target_dir="packages/$branch/$arch"
              if [ -d "$target_dir" ]; then
                if cp "$meta_file" "$target_dir/"; then
                  echo "  âœ… Copied metadata to: $target_dir/"
                else
                  echo "  âŒ Failed to copy metadata"
                fi
              else
                echo "  âš ï¸ Target directory not found: $target_dir"
              fi
            fi
          done
          
          # Final package count
          final_count=$(find packages -name "*.ipk" -o -name "*.apk" 2>/dev/null | wc -l)
          echo "ğŸ“Š Total packages organized: $final_count"
          
          # Show final structure
          echo "ğŸ“‚ Final package structure:"
          find packages -type d | sort
          
          # Update environment variable
          echo "PROCESSED_PACKAGES=$final_count" >> $GITHUB_ENV
          
          echo "::endgroup::"

      - name: ğŸ§¹ Intelligent repository cleanup
        run: |
          echo "::group::ğŸ§¹ Repository maintenance"
          
          if [ ! -d "packages" ]; then
            echo "ğŸ“‚ No packages directory found, skipping cleanup"
            echo "::endgroup::"
            exit 0
          fi
          
          current_size_gb=$(du -sb packages 2>/dev/null | awk '{print int($1/1024/1024/1024)}' || echo "0")
          echo "ğŸ“ Current repository size: ${current_size_gb}GB"
          
          if [ $current_size_gb -gt $MAX_REPO_SIZE_GB ] || [ "${{ github.event.inputs.force_cleanup }}" = "true" ]; then
            echo "ğŸ§¹ Cleanup required (size: ${current_size_gb}GB, limit: ${MAX_REPO_SIZE_GB}GB)"
            
            # Strategy 1: Remove duplicate packages (keep latest by version)
            echo "  ğŸ”„ Deduplicating packages..."
            find packages -name "*.ipk" -o -name "*.apk" 2>/dev/null | while read -r pkg; do
              base_name=$(basename "$pkg" | sed 's/_[^_]*\.\(ipk\|apk\)$//')
              pkg_dir=$(dirname "$pkg")
              
              # Find all versions of this package in the same directory
              find "$pkg_dir" -name "${base_name}_*" 2>/dev/null | sort -V | head -n -1 | while read -r old_pkg; do
                [ -f "$old_pkg" ] && rm -f "$old_pkg"
              done
            done
            
            # Strategy 2: Remove oldest snapshots first
            if [ -d "packages/SNAPSHOT" ]; then
              echo "  ğŸ—‘ï¸ Removing old snapshots..."
              find packages/SNAPSHOT -name "*.ipk" -o -name "*.apk" 2>/dev/null | \
                sort | head -n -$((MAX_REPO_SIZE_GB * 200)) | while read -r old_pkg; do
                [ -f "$old_pkg" ] && rm -f "$old_pkg"
              done
            fi
            
            # Strategy 3: Clean empty directories
            find packages -type d -empty -delete 2>/dev/null || true
            
            new_size_gb=$(du -sb packages 2>/dev/null | awk '{print int($1/1024/1024/1024)}' || echo "0")
            echo "  ğŸ“‰ Size after cleanup: ${new_size_gb}GB"
          fi
          
          echo "::endgroup::"

      - name: ğŸ“Š Generate advanced repository metadata
        id: generate_metadata
        run: |
          echo "::group::ğŸ“Š Generating metadata"
          
          # Calculate comprehensive statistics
          total_packages=$(find packages -name "*.ipk" -o -name "*.apk" 2>/dev/null | wc -l)
          total_branches=$(find packages -mindepth 1 -maxdepth 1 -type d 2>/dev/null | wc -l)
          total_archs=$(find packages -mindepth 2 -maxdepth 2 -type d 2>/dev/null | wc -l)
          repo_size_mb=$(du -sm packages 2>/dev/null | cut -f1 || echo "0")
          
          # Store metadata for later use
          echo "total_packages=$total_packages" >> $GITHUB_OUTPUT
          echo "total_branches=$total_branches" >> $GITHUB_OUTPUT
          echo "total_archs=$total_archs" >> $GITHUB_OUTPUT
          echo "repo_size_mb=$repo_size_mb" >> $GITHUB_OUTPUT
          
          # Create comprehensive repository metadata
          mkdir -p packages
          cat > packages/repository.json <<EOF
          {
            "repository": {
              "name": "ğŸš€ OpenWRT Custom Packages",
              "description": "Pre-built OpenWRT packages for multiple architectures and versions",
              "version": "2.0.0",
              "updated": "$(date -u '+%Y-%m-%dT%H:%M:%SZ')",
              "statistics": {
                "total_packages": $total_packages,
                "total_branches": $total_branches,
                "total_architectures": $total_archs,
                "repository_size_mb": $repo_size_mb,
                "last_build_packages": ${{ steps.download.outputs.total_packages || 0 }}
              },
              "branches": $(find packages -mindepth 1 -maxdepth 1 -type d -exec basename {} \; 2>/dev/null | sort | jq -R . | jq -s . || echo "[]"),
              "architectures": $(find packages -mindepth 2 -maxdepth 2 -type d -exec dirname {} \; 2>/dev/null | xargs -n1 basename | sort -u | jq -R . | jq -s . || echo "[]"),
              "build_info": {
                "workflow_run_id": "${{ github.event.inputs.runs_id }}",
                "commit_sha": "${{ github.sha }}",
                "trigger": "${{ github.event_name }}",
                "source_repository": "$SOURCE_REPO"
              },
              "usage": {
                "opkg_source": "src/gz custom_packages https://raw.githubusercontent.com/${{ github.repository }}/releases/packages/[BRANCH]/[ARCH]",
                "browse_url": "https://github.com/${{ github.repository }}/tree/releases/packages"
              }
            }
          }
          EOF
          
          # Generate repository structure overview
          echo "ğŸ“‚ Repository structure overview:"
          if [ -d "packages" ]; then
            for branch_dir in packages/*; do
              if [ -d "$branch_dir" ]; then
                branch_name=$(basename "$branch_dir")
                echo "  ğŸ“ $branch_name/"
                for arch_dir in "$branch_dir"/*; do
                  if [ -d "$arch_dir" ]; then
                    arch_name=$(basename "$arch_dir")
                    package_count=$(find "$arch_dir" -name "*.ipk" -o -name "*.apk" 2>/dev/null | wc -l)
                    echo "    ğŸ“ $arch_name/ ($package_count packages)"
                  fi
                done
              fi
            done
          fi
          
          echo "::endgroup::"
          echo "âœ… Generated enhanced repository metadata"

      - name: ğŸ“ Generate README
        run: |
          echo "::group::ğŸ“ Generating README"
          
          total_packages=$(find packages -name "*.ipk" -o -name "*.apk" 2>/dev/null | wc -l)
          total_branches=$(find packages -mindepth 1 -maxdepth 1 -type d 2>/dev/null | wc -l)
          total_archs=$(find packages -mindepth 2 -maxdepth 2 -type d 2>/dev/null | wc -l)
          repo_size_mb=$(du -sm packages 2>/dev/null | cut -f1 || echo "0")
          
          # Generate beautiful README with modern formatting
          cat > README.md <<'EOF'
          # ğŸš€ OpenWRT Custom Packages Repository
          
          <div align="center">
            <img src="https://img.shields.io/badge/OpenWRT-Packages-blue?style=for-the-badge&logo=openwrt" alt="OpenWRT Packages">
            <img src="https://img.shields.io/badge/Status-Active-success?style=for-the-badge" alt="Status">
            <img src="https://img.shields.io/badge/Auto--Updated-Weekly-informational?style=for-the-badge" alt="Auto Updated">
          </div>
          
          <div align="center">
            <h3>ğŸ¯ Pre-built packages for multiple OpenWRT versions and architectures</h3>
            <p><em>Automated builds â€¢ Quality assured â€¢ Always up-to-date</em></p>
          </div>
          
          ---
          
          ## ğŸ“Š Repository Statistics
          
          <table>
            <tr>
              <td align="center"><strong>ğŸ“¦ Total Packages</strong></td>
              <td align="center"><strong>ğŸ—ï¸ Architectures</strong></td>
              <td align="center"><strong>ğŸŒ¿ Branches</strong></td>
              <td align="center"><strong>ğŸ’¾ Repository Size</strong></td>
            </tr>
            <tr>
              <td align="center">
          EOF
          
          echo "    <img src=\"https://img.shields.io/badge/$total_packages-packages-blue?style=flat-square\" alt=\"$total_packages packages\">" >> README.md
          echo "  </td>" >> README.md
          echo "  <td align=\"center\">" >> README.md
          echo "    <img src=\"https://img.shields.io/badge/$total_archs-architectures-green?style=flat-square\" alt=\"$total_archs architectures\">" >> README.md
          echo "  </td>" >> README.md
          echo "  <td align=\"center\">" >> README.md
          echo "    <img src=\"https://img.shields.io/badge/$total_branches-branches-orange?style=flat-square\" alt=\"$total_branches branches\">" >> README.md
          echo "  </td>" >> README.md
          echo "  <td align=\"center\">" >> README.md
          echo "    <img src=\"https://img.shields.io/badge/${repo_size_mb}MB-size-red?style=flat-square\" alt=\"${repo_size_mb}MB\">" >> README.md
          echo "  </td>" >> README.md
          echo "</tr>" >> README.md
          echo "</table>" >> README.md
          echo "" >> README.md
          echo "> ğŸ• **Last updated**: $(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> README.md
          echo "" >> README.md
          
          # Generate branch information
          echo "## ğŸŒ¿ Supported OpenWRT Versions" >> README.md
          echo "" >> README.md
          
          if [ -d "packages" ]; then
            for branch_dir in packages/*; do
              if [ -d "$branch_dir" ]; then
                branch_name=$(basename "$branch_dir")
                branch_packages=$(find "$branch_dir" -name "*.ipk" -o -name "*.apk" 2>/dev/null | wc -l)
                branch_archs=$(find "$branch_dir" -mindepth 1 -maxdepth 1 -type d 2>/dev/null | wc -l)
                
                # Branch status badge
                if [ "$branch_name" = "SNAPSHOT" ]; then
                  badge="![SNAPSHOT](https://img.shields.io/badge/SNAPSHOT-Development-red?style=flat-square)"
                else
                  badge="![Stable](https://img.shields.io/badge/$branch_name-Stable-green?style=flat-square)"
                fi
                
                echo "### $badge" >> README.md
                echo "" >> README.md
                echo "| Architecture | Packages | Status |" >> README.md
                echo "|--------------|----------|--------|" >> README.md
                
                for arch_dir in "$branch_dir"/*; do
                  if [ -d "$arch_dir" ]; then
                    arch_name=$(basename "$arch_dir")
                    arch_packages=$(find "$arch_dir" -name "*.ipk" -o -name "*.apk" 2>/dev/null | wc -l)
                    if [ $arch_packages -gt 0 ]; then
                      echo "| \`$arch_name\` | $arch_packages | âœ… Available |" >> README.md
                    fi
                  fi
                done
                echo "" >> README.md
              fi
            done
          else
            echo "No packages available yet." >> README.md
            echo "" >> README.md
          fi
          
          # Add usage instructions
          cat >> README.md <<USAGE
          ## ğŸš€ Quick Start
          
          ### Method 1: Add Repository Source
          
          \`\`\`bash
          # Add custom repository (replace [BRANCH] and [ARCH] with your values)
          echo "src/gz custom_packages https://raw.githubusercontent.com/${{ github.repository }}/releases/packages/[BRANCH]/[ARCH]" >> /etc/opkg/customfeeds.conf
          
          # Update package lists
          opkg update
          
          # Install packages
          opkg install [package_name]
          \`\`\`
          
          ### Method 2: Direct Download
          
          Browse packages directly at: [ğŸ“‚ Package Browser](../../tree/releases/packages)
          
          ### Method 3: Auto-detect Architecture
          
          \`\`\`bash
          #!/bin/bash
          # Auto-detect architecture and install packages
          ARCH=\$(opkg print-architecture | awk 'NR==2{print \$2}')
          BRANCH="23.05"  # or 24.10, SNAPSHOT
          
          # Add repository
          echo "src/gz custom_packages https://raw.githubusercontent.com/${{ github.repository }}/releases/packages/\$BRANCH/\$ARCH" > /etc/opkg/customfeeds.conf
          
          # Update and install
          opkg update
          opkg list | grep custom_packages
          \`\`\`
          
          ## ğŸ“ Support
          
          - ğŸ› **Bug Reports**: [Create an Issue](../../issues/new)
          - ğŸ’¡ **Feature Requests**: [Request Feature](../../issues/new)
          - ğŸ“§ **Questions**: [Discussions](../../discussions)
          
          ---
          
          <div align="center">
            <sub>Built with â¤ï¸ using GitHub Actions â€¢ Powered by OpenWRT</sub>
          </div>
          USAGE
          
          echo "::endgroup::"
          echo "âœ… Generated README.md"

      - name: ğŸš€ Smart commit and deployment
        run: |
          echo "::group::ğŸš€ Deploying changes"
          
          # Check for changes
          if git diff --quiet && git diff --cached --quiet; then
            echo "â„¹ï¸ No changes to commit"
            echo "::endgroup::"
            exit 0
          fi
          
          # Stage all changes
          git add -A
          
          # Commit with detailed message
          total_packages=${PROCESSED_PACKAGES:-$(find packages -name '*.ipk' -o -name '*.apk' 2>/dev/null | wc -l)}
          
          git commit -m "ğŸ“¦ Release OpenWRT packages" \
                    -m "ğŸ• Updated: $(date -u '+%Y-%m-%d %H:%M:%S UTC')" \
                    -m "ğŸ“¦ Total packages: $total_packages" \
                    -m "ğŸ—ï¸ Build ID: ${{ github.event.inputs.runs_id }}" \
                    -m "ğŸŒ¿ Source: $SOURCE_REPO" \
                    -m "" \
                    -m "Changes:" \
                    -m "- Organized packages by branch/architecture structure" \
                    -m "- Updated repository metadata and README" \
                    -m "- Applied intelligent cleanup if needed"
          
          echo "::endgroup::"

      - name: ğŸŒ Push to GitHub
        run: |
          echo "::group::ğŸŒ Pushing to GitHub"
          
          # Enhanced push with retry mechanism
          max_retries=5
          retry_delay=30
          
          for attempt in $(seq 1 $max_retries); do
            echo "ğŸš€ Push attempt $attempt/$max_retries"
            
            if git push origin releases; then
              echo "âœ… Successfully pushed on attempt $attempt"
              echo "ğŸ‰ Deployment completed successfully!"
              break
            else
              echo "âš ï¸ Push attempt $attempt failed"
              
              if [ $attempt -eq $max_retries ]; then
                echo "âŒ All push attempts failed"
                exit 1
              fi
              
              echo "â³ Waiting ${retry_delay}s before retry..."
              sleep $retry_delay
              
              # Try to resolve conflicts
              echo "ğŸ”„ Attempting to resolve conflicts..."
              if git pull --rebase origin releases; then
                echo "âœ… Conflicts resolved with rebase"
              else
                echo "âŒ Rebase failed, trying merge"
                git rebase --abort 2>/dev/null || true
                if git pull --strategy-option=theirs origin releases; then
                  echo "âœ… conflicts resolved with merge"
                else
                  echo "âŒ Failed to resolve conflicts"
                  continue
                fi
              fi
              
              # Exponential backoff
              retry_delay=$((retry_delay * 2))
            fi
          done
          
          echo "::endgroup::"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: ğŸ‰ Generate success summary
        if: success()
        run: |
          total_packages=$(find packages -name "*.ipk" -o -name "*.apk" 2>/dev/null | wc -l)
          repo_size=$(du -sh packages 2>/dev/null | cut -f1 || echo "0B")
          
          cat >> $GITHUB_STEP_SUMMARY <<EOF
          ## ğŸ‰ Release Completed Successfully!
          
          ### ğŸ“Š Final Statistics
          - **Total Packages**: $total_packages
          - **Repository Size**: $repo_size
          - **Build Source**: Run ID ${{ github.event.inputs.runs_id }}
          - **Commit SHA**: \`${{ github.sha }}\`
          
          ### ğŸ”— Quick Links
          - ğŸ“¦ [Browse Packages](../../tree/releases/packages)
          - ğŸ“‹ [Repository Metadata](../../blob/releases/packages/repository.json)
          - ğŸƒ [View Workflow](../../actions/runs/${{ github.run_id }})
          
          ### ğŸ“‚ Package Structure
          \`\`\`
          packages/
          $(find packages -type d | sed 's|packages/||' | sed 's|^|  |' | sort)
          \`\`\`
          
          ### ğŸš€ What's Next?
          1. Packages are now available in the \`releases\` branch
          2. Users can add the repository to their OpenWRT devices
          3. Automated builds keep packages updated
          
          ---
          *Generated on $(date -u '+%Y-%m-%d %H:%M:%S UTC') by GitHub Actions*
          EOF

  cleanup:
    name: ğŸ§¹ Cleanup & Maintenance
    runs-on: ubuntu-latest
    needs: release
    if: always()
    
    steps:
      - name: ğŸ“Š Workflow summary
        run: |
          echo "### ğŸ Workflow Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Job | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-----|--------|" >> $GITHUB_STEP_SUMMARY
          
          case "${{ needs.release.result }}" in
            "success")
              status="âœ… Success"
              ;;
            "failure")
              status="âŒ Failed"
              ;;
            "cancelled")
              status="ğŸš« Cancelled"
              ;;
            *)
              status="â­ï¸ Skipped"
              ;;
          esac
          
          echo "| Release | $status |" >> $GITHUB_STEP_SUMMARY

      - name: ğŸ”” Notification on failure
        if: failure() || needs.release.result == 'failure'
        run: |
          echo "::error title=Workflow Failed::âŒ The OpenWRT package release workflow has failed"
          echo "Please check the logs and fix any issues before the next scheduled run."
          echo "::notice::Check the workflow logs for detailed error information."