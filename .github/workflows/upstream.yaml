name: ğŸš€ KWRT Packages Sync Pipeline

on:
  # â° Daily sync at 02:00 UTC
  schedule:
    - cron: '0 2 * * *'
  
  # ğŸ¯ Manual trigger with advanced options
  workflow_dispatch:
    inputs:
      force_sync:
        description: 'âš¡ Force sync regardless of changes'
        required: false
        default: false
        type: boolean
      
      sync_mode:
        description: 'ğŸ”„ Sync mode'
        required: false
        default: 'standard'
        type: choice
        options:
          - standard
          - deep-clean
          - quick-check
          - merge-only
      
      notification_level:
        description: 'ğŸ“¢ Notification level'
        required: false
        default: 'normal'
        type: choice
        options:
          - minimal
          - normal
          - verbose

env:
  # ğŸŒŸ Configuration
  KWRT_REPO_URL: https://github.com/kiddin9/kwrt-packages
  PACKAGES_DIR: packages
  WORKFLOW_VERSION: "2.1.0"
  MANUAL_PACKAGES_FILE: ".manual-packages"
  SYNC_METADATA_FILE: ".sync-metadata.json"
  
  # ğŸ¨ Styling
  EMOJI_SUCCESS: "âœ¨"
  EMOJI_ERROR: "ğŸ”¥"
  EMOJI_INFO: "ğŸ’¡"
  EMOJI_SYNC: "âš¡"

jobs:
  # ğŸ” Pre-flight checks
  preflight:
    name: ğŸ›¡ï¸ Pre-flight Validation
    runs-on: ubuntu-latest
    outputs:
      should_proceed: ${{ steps.validation.outputs.proceed }}
      source_available: ${{ steps.validation.outputs.source_ok }}
    
    steps:
    - name: ğŸ” Validate Source Repository
      id: validation
      run: |
        echo "ğŸ” Validating source repository accessibility..."
        
        # Check if source repo is accessible
        if curl -s --head "${{ env.KWRT_REPO_URL }}"; then
          echo "âœ… Source repository is accessible"
          echo "source_ok=true" >> $GITHUB_OUTPUT
          echo "proceed=true" >> $GITHUB_OUTPUT
        else
          echo "âŒ Source repository is not accessible"
          echo "source_ok=false" >> $GITHUB_OUTPUT
          echo "proceed=false" >> $GITHUB_OUTPUT
        fi

  # ğŸš€ Main sync job
  sync-packages:
    name: ğŸš€ Package Synchronization
    runs-on: ubuntu-latest
    needs: preflight
    if: needs.preflight.outputs.should_proceed == 'true'
    
    steps:
    - name: ğŸ¯ Initialize Workspace
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0
        
    - name: ğŸ”§ Configure Environment
      run: |
        echo "ğŸ”§ Setting up advanced sync environment..."
        
        # Environment variables
        echo "SOURCE_URL=${{ env.KWRT_REPO_URL }}" >> $GITHUB_ENV
        echo "SYNC_TIMESTAMP=$(date +'%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_ENV
        echo "SYNC_ID=$(date +'%Y%m%d%H%M%S')" >> $GITHUB_ENV
        echo "WORKFLOW_VERSION=${{ env.WORKFLOW_VERSION }}" >> $GITHUB_ENV
        
        # Sync mode configuration
        case "${{ github.event.inputs.sync_mode || 'standard' }}" in
          "deep-clean")
            echo "SYNC_MODE=ğŸ§¹ Deep Clean" >> $GITHUB_ENV
            echo "CLEAN_STRATEGY=aggressive" >> $GITHUB_ENV
            ;;
          "quick-check")
            echo "SYNC_MODE=âš¡ Quick Check" >> $GITHUB_ENV
            echo "CLEAN_STRATEGY=minimal" >> $GITHUB_ENV
            ;;
          "merge-only")
            echo "SYNC_MODE=ğŸ”„ Merge Only" >> $GITHUB_ENV
            echo "CLEAN_STRATEGY=merge" >> $GITHUB_ENV
            ;;
          *)
            echo "SYNC_MODE=ğŸ”„ Standard" >> $GITHUB_ENV
            echo "CLEAN_STRATEGY=standard" >> $GITHUB_ENV
            ;;
        esac
        
        # Create sync metadata
        echo "ğŸ“Š Sync Configuration:"
        echo "  ğŸ†” Sync ID: $SYNC_ID"
        echo "  ğŸ•’ Timestamp: $(date +'%Y-%m-%d %H:%M:%S UTC')"
        echo "  ğŸ”„ Mode: $SYNC_MODE"
        echo "  ğŸ“¦ Version: ${{ env.WORKFLOW_VERSION }}"

    - name: ğŸ—ï¸ Prepare Workspace & Inventory
      run: |
        echo "ğŸ—ï¸ Preparing synchronized workspace with inventory protection..."
        
        # Create directory structure
        mkdir -p ${{ env.PACKAGES_DIR }}
        mkdir -p .sync-metadata
        
        # Create or load manual packages registry
        if [ ! -f "${{ env.MANUAL_PACKAGES_FILE }}" ]; then
          echo "ğŸ“ Creating manual packages registry..."
          echo "# Manual/Contributed Packages Registry" > "${{ env.MANUAL_PACKAGES_FILE }}"
          echo "# Add package names (one per line) that should NOT be removed during sync" >> "${{ env.MANUAL_PACKAGES_FILE }}"
          echo "# Format: package-name or directory-name" >> "${{ env.MANUAL_PACKAGES_FILE }}"
          echo "" >> "${{ env.MANUAL_PACKAGES_FILE }}"
        fi
        
        # Load sync metadata if exists
        if [ -f "${{ env.SYNC_METADATA_FILE }}" ]; then
          echo "ğŸ“‹ Loading existing sync metadata..."
          cp "${{ env.SYNC_METADATA_FILE }}" .sync-metadata/previous-sync.json
        else
          echo "ğŸ“‹ Creating initial sync metadata..."
        fi
        
        # Inventory current packages
        echo "ğŸ“¦ Creating current package inventory..."
        find ${{ env.PACKAGES_DIR }} -maxdepth 1 -not -name '.*' -not -name ${{ env.PACKAGES_DIR }} \
          -printf "%f\n" 2>/dev/null | sort > .sync-metadata/current-packages.txt || echo > .sync-metadata/current-packages.txt
        
        # Load manual packages list (excluding comments and empty lines)
        grep -v '^#\|^$' "${{ env.MANUAL_PACKAGES_FILE }}" 2>/dev/null | sort > .sync-metadata/manual-packages.txt || echo > .sync-metadata/manual-packages.txt
        
        # Show inventory summary
        CURRENT_COUNT=$(wc -l < .sync-metadata/current-packages.txt)
        MANUAL_COUNT=$(wc -l < .sync-metadata/manual-packages.txt)
        
        echo "ğŸ“Š Package Inventory:"
        echo "  ğŸ“¦ Current packages: $CURRENT_COUNT"
        echo "  ğŸ”’ Protected packages: $MANUAL_COUNT"
        
        if [ $MANUAL_COUNT -gt 0 ]; then
          echo "ğŸ”’ Protected packages list:"
          sed 's/^/    - /' .sync-metadata/manual-packages.txt
        fi
        
        # Preserve important files
        if [ -f ${{ env.PACKAGES_DIR }}/.gitkeep ]; then
          echo "ğŸ’¾ Preserving .gitkeep file..."
          cp ${{ env.PACKAGES_DIR }}/.gitkeep .sync-metadata/.gitkeep.backup
        fi
        
        # Create sync manifest
        cat > .sync-metadata/sync-manifest.json << EOF
        {
          "sync_id": "${{ env.SYNC_ID }}",
          "timestamp": "${{ env.SYNC_TIMESTAMP }}",
          "source_url": "${{ env.KWRT_REPO_URL }}",
          "workflow_version": "${{ env.WORKFLOW_VERSION }}",
          "sync_mode": "${{ env.SYNC_MODE }}",
          "triggered_by": "${{ github.event_name }}",
          "actor": "${{ github.actor }}",
          "protected_packages_count": $MANUAL_COUNT,
          "current_packages_count": $CURRENT_COUNT
        }
        EOF
        
        echo "âœ… Workspace prepared successfully!"

    - name: ğŸ“¡ Fetch Source Repository
      run: |
        echo "ğŸ“¡ Fetching latest packages from source..."
        echo "ğŸ¯ Source: ${{ env.KWRT_REPO_URL }}"
        
        # Download with progress and retry logic
        for attempt in 1 2 3; do
          echo "ğŸ”„ Attempt $attempt/3..."
          
          if wget -q --show-progress --progress=bar:force \
            --timeout=30 --tries=3 \
            -O kwrt-packages.zip \
            "${{ env.KWRT_REPO_URL }}/archive/refs/heads/main.zip"; then
            
            echo "âœ… Download successful on attempt $attempt!"
            break
          else
            echo "âš ï¸ Attempt $attempt failed, retrying..."
            [ $attempt -eq 3 ] && exit 1
            sleep 5
          fi
        done
        
        # Verify download
        if [ ! -f kwrt-packages.zip ] || [ ! -s kwrt-packages.zip ]; then
          echo "âŒ Download verification failed!"
          exit 1
        fi
        
        echo "ğŸ“Š Download statistics:"
        ls -lah kwrt-packages.zip
        echo "ğŸ” File integrity: $(sha256sum kwrt-packages.zip | cut -d' ' -f1)"

    - name: ğŸ Extract and Smart Merge
      run: |
        echo "ğŸ Processing downloaded archive with smart merge..."
        
        # Extract with verification
        if ! unzip -q kwrt-packages.zip; then
          echo "âŒ Archive extraction failed!"
          exit 1
        fi
        
        # Create staging area
        mkdir -p .sync-staging
        
        echo "ğŸ“¦ Analyzing source packages..."
        cd kwrt-packages-main
        
        # Count and categorize source files
        TOTAL_FILES=$(find . -maxdepth 1 -type f -not -name 'README*' -not -name '.*' | wc -l)
        TOTAL_DIRS=$(find . -maxdepth 1 -type d -not -name '.' -not -name '.github' -not -name '.git' | wc -l)
        
        echo "ğŸ“Š Source statistics:"
        echo "  ğŸ“„ Files: $TOTAL_FILES"
        echo "  ğŸ“ Directories: $TOTAL_DIRS"
        
        # Move source files to staging
        find . -maxdepth 1 -type f \
          -not -name 'README*' \
          -not -name 'LICENSE*' \
          -not -name '.*' \
          -not -name '*.md' \
          -exec mv {} ../.sync-staging/ \; 2>/dev/null || true
        
        find . -maxdepth 1 -type d \
          -not -name '.' \
          -not -name '.github' \
          -not -name '.git' \
          -exec mv {} ../.sync-staging/ \; 2>/dev/null || true
        
        cd ..
        
        # Create source package inventory
        find .sync-staging -maxdepth 1 -not -name '.*' -not -name .sync-staging \
          -printf "%f\n" 2>/dev/null | sort > .sync-metadata/source-packages.txt || echo > .sync-metadata/source-packages.txt
        
        SOURCE_COUNT=$(wc -l < .sync-metadata/source-packages.txt)
        echo "ğŸ“¦ Source packages: $SOURCE_COUNT"
        
        # Perform smart merge based on strategy
        echo "ğŸ”„ Applying ${{ env.CLEAN_STRATEGY }} merge strategy..."
        
        case "${{ env.CLEAN_STRATEGY }}" in
          "aggressive")
            echo "ğŸ§¹ Performing aggressive merge (removes ALL non-protected packages)..."
            # Remove all packages except protected ones
            while IFS= read -r package; do
              if [ -n "$package" ]; then
                PACKAGE_PATH="${{ env.PACKAGES_DIR }}/$package"
                if [ -e "$PACKAGE_PATH" ]; then
                  # Check if package is protected
                  if ! grep -Fxq "$package" .sync-metadata/manual-packages.txt; then
                    echo "ğŸ—‘ï¸ Removing unprotected package: $package"
                    rm -rf "$PACKAGE_PATH"
                  else
                    echo "ğŸ”’ Preserving protected package: $package"
                  fi
                fi
              fi
            done < .sync-metadata/current-packages.txt
            ;;
            
          "minimal")
            echo "ğŸ§¹ Performing minimal merge (only updates existing)..."
            # Only update packages that exist in both source and destination
            comm -12 .sync-metadata/source-packages.txt .sync-metadata/current-packages.txt | \
            while IFS= read -r package; do
              if [ -n "$package" ]; then
                # Check if package is protected before updating
                if ! grep -Fxq "$package" .sync-metadata/manual-packages.txt; then
                  echo "ğŸ”„ Updating existing package: $package"
                  rm -rf "${{ env.PACKAGES_DIR }}/$package"
                else
                  echo "ğŸ”’ Skipping protected package: $package"
                fi
              fi
            done
            ;;
            
          "merge")
            echo "ğŸ”„ Performing merge-only (preserves all existing)..."
            # Don't remove anything, only add new packages
            echo "â„¹ï¸ All existing packages will be preserved"
            ;;
            
          *)
            echo "ğŸ”„ Performing standard merge (removes only conflicting non-protected)..."
            # Remove packages that exist in destination but check protection
            while IFS= read -r package; do
              if [ -n "$package" ]; then
                PACKAGE_PATH="${{ env.PACKAGES_DIR }}/$package"
                if [ -e "$PACKAGE_PATH" ]; then
                  # Check if package is protected
                  if ! grep -Fxq "$package" .sync-metadata/manual-packages.txt; then
                    # Check if package exists in source (will be replaced)
                    if grep -Fxq "$package" .sync-metadata/source-packages.txt; then
                      echo "ğŸ”„ Replacing package: $package"
                      rm -rf "$PACKAGE_PATH"
                    fi
                  else
                    echo "ğŸ”’ Preserving protected package: $package"
                  fi
                fi
              fi
            done < .sync-metadata/current-packages.txt
            ;;
        esac
        
        # Move new/updated packages from staging to destination
        echo "ğŸ“¦ Installing source packages..."
        INSTALLED_COUNT=0
        SKIPPED_COUNT=0
        
        if [ -d .sync-staging ]; then
          for item in .sync-staging/*; do
            if [ -e "$item" ] && [ "$item" != ".sync-staging/*" ]; then
              PACKAGE_NAME=$(basename "$item")
              DEST_PATH="${{ env.PACKAGES_DIR }}/$PACKAGE_NAME"
              
              # Check if destination exists and is protected
              if [ -e "$DEST_PATH" ] && grep -Fxq "$PACKAGE_NAME" .sync-metadata/manual-packages.txt 2>/dev/null; then
                echo "ğŸ”’ Skipping protected package: $PACKAGE_NAME"
                SKIPPED_COUNT=$((SKIPPED_COUNT + 1))
              else
                echo "âœ… Installing package: $PACKAGE_NAME"
                if mv "$item" "$DEST_PATH" 2>/dev/null; then
                  INSTALLED_COUNT=$((INSTALLED_COUNT + 1))
                else
                  echo "âš ï¸ Failed to move package: $PACKAGE_NAME"
                fi
              fi
            fi
          done
        fi
        
        # Restore preserved files
        if [ -f .sync-metadata/.gitkeep.backup ]; then
          echo "ğŸ’¾ Restoring preserved files..."
          mv .sync-metadata/.gitkeep.backup ${{ env.PACKAGES_DIR }}/.gitkeep
        fi
        
        # Update sync metadata
        cat > "${{ env.SYNC_METADATA_FILE }}" << EOF
        {
          "last_sync_id": "${{ env.SYNC_ID }}",
          "last_sync_timestamp": "${{ env.SYNC_TIMESTAMP }}",
          "last_sync_mode": "${{ env.SYNC_MODE }}",
          "source_packages_count": $SOURCE_COUNT,
          "workflow_version": "${{ env.WORKFLOW_VERSION }}"
        }
        EOF
        
        # Cleanup
        echo "ğŸ§¹ Cleaning temporary files..."
        rm -rf kwrt-packages.zip kwrt-packages-main .sync-staging
        
        echo "âœ… Smart merge completed successfully!"
        echo "ğŸ“Š Final statistics:"
        echo "  ğŸ“¦ Source packages: $SOURCE_COUNT"

    - name: ğŸ”¬ Advanced Change Analysis
      id: analyze
      run: |
        echo "ğŸ”¬ Performing advanced change analysis..."
        
        # Check for git changes
        git add -A
        
        # Detailed git analysis with error handling
        if git diff --cached --quiet; then
          echo "has_changes=false" >> $GITHUB_OUTPUT
          echo "total_changes=0" >> $GITHUB_OUTPUT
          echo "change_magnitude=none" >> $GITHUB_OUTPUT
          echo "â„¹ï¸ No changes detected - repository is up to date"
        else
          echo "ğŸ¯ Changes detected!"
          echo "has_changes=true" >> $GITHUB_OUTPUT
          
          # Initialize counters
          ADDED=0
          MODIFIED=0
          DELETED=0
          RENAMED=0
          UNTRACKED=0
          
          # Safe change counting with error handling
          if git status --porcelain > /tmp/git_status.txt 2>/dev/null; then
            while IFS= read -r line || [ -n "$line" ]; do
              if [ -n "$line" ]; then
                case "${line:0:2}" in
                  "A "|\
                  "AM") ADDED=$((ADDED + 1)) ;;
                  "M "|\
                  "MM"|\
                  " M") MODIFIED=$((MODIFIED + 1)) ;;
                  "D "|\
                  " D") DELETED=$((DELETED + 1)) ;;
                  "R "|\
                  "RM") RENAMED=$((RENAMED + 1)) ;;
                  "??"|\
                  "A ") UNTRACKED=$((UNTRACKED + 1)) ;;
                esac
              fi
            done < /tmp/git_status.txt
            
            # Clean up temp file
            rm -f /tmp/git_status.txt
          else
            # Fallback: count all changes as modified
            MODIFIED=$(git diff --cached --name-only | wc -l)
            echo "âš ï¸ Using fallback change detection"
          fi
          
          # Calculate total changes safely
          TOTAL_CHANGES=$((ADDED + MODIFIED + DELETED + RENAMED + UNTRACKED))
          
          # Ensure we have at least 1 change if git detected changes
          if [ $TOTAL_CHANGES -eq 0 ]; then
            TOTAL_CHANGES=1
            MODIFIED=1
            echo "âš ï¸ Adjusted change count to reflect detected modifications"
          fi
          
          # Set outputs safely
          echo "added=${ADDED}" >> $GITHUB_OUTPUT
          echo "modified=${MODIFIED}" >> $GITHUB_OUTPUT
          echo "deleted=${DELETED}" >> $GITHUB_OUTPUT
          echo "renamed=${RENAMED}" >> $GITHUB_OUTPUT
          echo "untracked=${UNTRACKED}" >> $GITHUB_OUTPUT
          echo "total_changes=${TOTAL_CHANGES}" >> $GITHUB_OUTPUT
          
          # Determine change magnitude
          if [ $TOTAL_CHANGES -gt 100 ]; then
            echo "change_magnitude=major" >> $GITHUB_OUTPUT
            echo "ğŸ”¥ Major changes detected ($TOTAL_CHANGES files)"
          elif [ $TOTAL_CHANGES -gt 20 ]; then
            echo "change_magnitude=moderate" >> $GITHUB_OUTPUT
            echo "âš¡ Moderate changes detected ($TOTAL_CHANGES files)"
          else
            echo "change_magnitude=minor" >> $GITHUB_OUTPUT
            echo "âœ¨ Minor changes detected ($TOTAL_CHANGES files)"
          fi
          
          # Enhanced change summary
          echo "ğŸ“Š Detailed Change Analysis:"
          echo "  â• Added: $ADDED"
          echo "  âœï¸ Modified: $MODIFIED"
          echo "  âŒ Deleted: $DELETED"
          echo "  ğŸ”„ Renamed: $RENAMED"
          echo "  ğŸ“„ Untracked: $UNTRACKED"
          echo "  ğŸ“ˆ Total: $TOTAL_CHANGES"
          
          # Show protected packages info
          PROTECTED_COUNT=$(wc -l < .sync-metadata/manual-packages.txt 2>/dev/null || echo 0)
          echo "  ğŸ”’ Protected: $PROTECTED_COUNT packages"
        fi

    - name: ğŸš€ Smart Commit & Deploy
      if: steps.analyze.outputs.has_changes == 'true' || github.event.inputs.force_sync == 'true'
      run: |
        echo "ğŸš€ Deploying changes with smart commit..."
        
        # Configure git with enhanced identity
        git config --global user.email "noreply@github.com"
        git config --global user.name "ğŸ¤– KWRT Sync Bot v${{ env.WORKFLOW_VERSION }}"
        
        # Generate smart commit message
        MAGNITUDE="${{ steps.analyze.outputs.change_magnitude || 'forced' }}"
        TOTAL_CHANGES="${{ steps.analyze.outputs.total_changes || '0' }}"
        PROTECTED_COUNT=$(wc -l < .sync-metadata/manual-packages.txt 2>/dev/null || echo 0)
        
        case "$MAGNITUDE" in
          "major")
            COMMIT_ICON="ğŸ”¥"
            COMMIT_TYPE="feat"
            ;;
          "moderate")
            COMMIT_ICON="âš¡"
            COMMIT_TYPE="update"
            ;;
          "minor")
            COMMIT_ICON="âœ¨"
            COMMIT_TYPE="sync"
            ;;
          "forced")
            COMMIT_ICON="ğŸš€"
            COMMIT_TYPE="force"
            ;;
          *)
            COMMIT_ICON="ğŸ”„"
            COMMIT_TYPE="sync"
            ;;
        esac
        
        # Create semantic commit message
        COMMIT_MSG="$COMMIT_ICON $COMMIT_TYPE: KWRT packages sync ($TOTAL_CHANGES changes)

        ğŸ¯ Sync Details:
        â”œâ”€ ğŸ“… Date: ${{ env.SYNC_TIMESTAMP }}
        â”œâ”€ ğŸ†” ID: ${{ env.SYNC_ID }}
        â”œâ”€ ğŸ”„ Mode: ${{ env.SYNC_MODE }}
        â”œâ”€ ğŸ“¦ Version: ${{ env.WORKFLOW_VERSION }}
        â”œâ”€ ğŸ”’ Protected: $PROTECTED_COUNT packages
        â””â”€ ğŸ“¡ Source: ${{ env.KWRT_REPO_URL }}
        
        ğŸ“Š Change Summary:
        â”œâ”€ â• Added: ${{ steps.analyze.outputs.added || 0 }}
        â”œâ”€ âœï¸ Modified: ${{ steps.analyze.outputs.modified || 0 }}
        â”œâ”€ âŒ Deleted: ${{ steps.analyze.outputs.deleted || 0 }}
        â”œâ”€ ğŸ”„ Renamed: ${{ steps.analyze.outputs.renamed || 0 }}
        â””â”€ ğŸ“„ New: ${{ steps.analyze.outputs.untracked || 0 }}
        
        ğŸ”’ Protected packages preserved during sync
        ğŸ¤– Automated by GitHub Actions
        ğŸ”— Workflow: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
        
        # Add all changes including metadata files
        git add ${{ env.PACKAGES_DIR }}/
        git add "${{ env.SYNC_METADATA_FILE }}"
        git add "${{ env.MANUAL_PACKAGES_FILE }}"
        git commit -m "$COMMIT_MSG"
        git push
        
        echo "âœ… Changes deployed successfully!"

    - name: ğŸ“Š Generate Advanced Report
      run: |
        echo "ğŸ“Š Generating comprehensive sync report..."
        
        # Load statistics
        PROTECTED_COUNT=$(wc -l < .sync-metadata/manual-packages.txt 2>/dev/null || echo 0)
        CURRENT_COUNT=$(find ${{ env.PACKAGES_DIR }} -maxdepth 1 -not -name '.*' -not -name ${{ env.PACKAGES_DIR }} | wc -l)
        
        # Determine status
        if [[ "${{ steps.analyze.outputs.has_changes }}" == "true" ]]; then
          STATUS_ICON="âœ…"
          STATUS_TEXT="SUCCESS"
          STATUS_COLOR="green"
        elif [[ "${{ github.event.inputs.force_sync }}" == "true" ]]; then
          STATUS_ICON="ğŸš€"
          STATUS_TEXT="FORCED"
          STATUS_COLOR="blue"
        else
          STATUS_ICON="â„¹ï¸"
          STATUS_TEXT="NO CHANGES"
          STATUS_COLOR="gray"
        fi
        
        # Generate advanced report
        cat >> $GITHUB_STEP_SUMMARY << EOF
        # ğŸš€ KWRT Packages Sync Report v${{ env.WORKFLOW_VERSION }}
        
        ## $STATUS_ICON Status: **$STATUS_TEXT**
        
        ### ğŸ“‹ Sync Information
        
        | ğŸ·ï¸ Property | ğŸ“ Value |
        |-------------|----------|
        | **ğŸ†” Sync ID** | \`${{ env.SYNC_ID }}\` |
        | **ğŸ“… Timestamp** | \`${{ env.SYNC_TIMESTAMP }}\` |
        | **ğŸ”„ Mode** | ${{ env.SYNC_MODE }} |
        | **ğŸ“¦ Version** | \`${{ env.WORKFLOW_VERSION }}\` |
        | **ğŸ‘¤ Triggered By** | \`${{ github.actor }}\` |
        | **ğŸ¯ Event** | \`${{ github.event_name }}\` |
        | **ğŸ“¡ Source** | [${{ env.KWRT_REPO_URL }}](${{ env.KWRT_REPO_URL }}) |
        | **ğŸ”— Workflow** | [Run #${{ github.run_id }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) |
        
        ### ğŸ”’ Package Protection Status
        
        | ğŸ“Š Category | ğŸ”¢ Count | ğŸ“ Description |
        |-------------|----------|----------------|
        | **ğŸ”’ Protected Packages** | \`$PROTECTED_COUNT\` | Manual/contributed packages preserved |
        | **ğŸ“¦ Total Packages** | \`$CURRENT_COUNT\` | All packages in repository |
        | **âš¡ Sync Eligible** | \`$((CURRENT_COUNT - PROTECTED_COUNT))\` | Packages managed by sync |
        
        EOF
        
        # Show protected packages if any
        if [ $PROTECTED_COUNT -gt 0 ]; then
          cat >> $GITHUB_STEP_SUMMARY << EOF
        ### ğŸ”’ Protected Packages List
        
        EOF
          while IFS= read -r package; do
            if [ -n "$package" ]; then
              echo "- \`$package\`" >> $GITHUB_STEP_SUMMARY
            fi
          done < .sync-metadata/manual-packages.txt
          
          cat >> $GITHUB_STEP_SUMMARY << EOF
        
        EOF
        fi
        
        # Add change details if applicable
        if [[ "${{ steps.analyze.outputs.has_changes }}" == "true" ]]; then
          MAGNITUDE="${{ steps.analyze.outputs.change_magnitude }}"
          
          case "$MAGNITUDE" in
            "major") MAGNITUDE_ICON="ğŸ”¥"; MAGNITUDE_DESC="Major Update" ;;
            "moderate") MAGNITUDE_ICON="âš¡"; MAGNITUDE_DESC="Moderate Update" ;;
            "minor") MAGNITUDE_ICON="âœ¨"; MAGNITUDE_DESC="Minor Update" ;;
            *) MAGNITUDE_ICON="ğŸ”„"; MAGNITUDE_DESC="Standard Update" ;;
          esac
          
          cat >> $GITHUB_STEP_SUMMARY << EOF
        ### $MAGNITUDE_ICON Change Analysis: **$MAGNITUDE_DESC**
        
        | ğŸ“Š Change Type | ğŸ”¢ Count | ğŸ“ˆ Impact |
        |----------------|----------|-----------|
        | â• **Added** | \`${{ steps.analyze.outputs.added || 0 }}\` | New packages/files |
        | âœï¸ **Modified** | \`${{ steps.analyze.outputs.modified || 0 }}\` | Updated content |
        | âŒ **Deleted** | \`${{ steps.analyze.outputs.deleted || 0 }}\` | Removed items |
        | ğŸ”„ **Renamed** | \`${{ steps.analyze.outputs.renamed || 0 }}\` | Restructured files |
        | ğŸ“„ **New Files** | \`${{ steps.analyze.outputs.untracked || 0 }}\` | Fresh additions |
        | **ğŸ¯ Total Changes** | **\`${{ steps.analyze.outputs.total_changes || 0 }}\`** | **Overall impact** |
        
        EOF
        fi
        
        # Add instructions for managing protected packages
        cat >> $GITHUB_STEP_SUMMARY << EOF
        ### ğŸ› ï¸ Managing Protected Packages
        
        To protect packages from being removed during sync:
        
        1. **Add to protection list**: Edit \`${{ env.MANUAL_PACKAGES_FILE }}\` file
        2. **Add package name**: One package name per line (e.g., \`my-custom-package\`)
        3. **Commit changes**: Protected packages list is version controlled
        
        **Example \`${{ env.MANUAL_PACKAGES_FILE }}\`:**
        \`\`\`
        # Manual/Contributed Packages Registry
        my-custom-package
        contributed-tool
        local-modification
        \`\`\`
        
        ---
        
        ### ğŸ¯ Quick Actions
        
        - ğŸ”„ [View Source Repository](${{ env.KWRT_REPO_URL }})
        - ğŸ“¦ [Browse Packages](${{ github.server_url }}/${{ github.repository }}/tree/main/${{ env.PACKAGES_DIR }})
        - ğŸ”’ [Edit Protected Packages](${{ github.server_url }}/${{ github.repository }}/edit/main/${{ env.MANUAL_PACKAGES_FILE }})
        - ğŸ“Š [Workflow History](${{ github.server_url }}/${{ github.repository }}/actions/workflows/sync-kwrt.yml)
        - ğŸš€ [Manual Sync](${{ github.server_url }}/${{ github.repository }}/actions/workflows/sync-kwrt.yml)
        
        ---
        
        <div align="center">
        
        **ğŸ¤– Powered by GitHub Actions** â€¢ **âš¡ KWRT Sync Bot v${{ env.WORKFLOW_VERSION }}**
        
        *Intelligent package synchronization with contribution protection*
        
        </div>
        EOF

    - name: ğŸ‰ Sync Complete
      run: |
        echo "ğŸ‰ KWRT Packages sync pipeline completed successfully!"
        echo ""
        echo "ğŸ“Š Final Summary:"
        echo "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”"
        echo "â”‚                    ğŸš€ SYNC COMPLETED                        â”‚"
        echo "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤"
        echo "â”‚ ğŸ†” Sync ID: ${{ env.SYNC_ID }}                   â”‚"
        echo "â”‚ ğŸ“… Date: ${{ env.SYNC_TIMESTAMP }}                    â”‚"
        echo "â”‚ ğŸ”„ Mode: ${{ env.SYNC_MODE }}                           â”‚"
        echo "â”‚ ğŸ“¦ Version: ${{ env.WORKFLOW_VERSION }}                            â”‚"
        echo "â”‚ ğŸ¯ Status: $([ "${{ steps.analyze.outputs.has_changes }}" == "true" ] && echo "âœ… Updated" || echo "â„¹ï¸ No changes")                                 â”‚"
        echo "â”‚ ğŸ“Š Changes: ${{ steps.analyze.outputs.total_changes || 0 }} files affected                          â”‚"
        echo "â”‚ ğŸ”’ Protected: $(wc -l < .sync-metadata/manual-packages.txt 2>/dev/null || echo 0) packages preserved                       â”‚"
        echo "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜"
        echo ""
        echo "ğŸ”’ Manual/contributed packages are preserved during sync"
        echo "ğŸ“ To protect packages: edit ${{ env.MANUAL_PACKAGES_FILE }}"
        echo "ğŸš€ Next sync scheduled for tomorrow at 02:00 UTC"
        echo "âš¡ Manual sync available via workflow dispatch"