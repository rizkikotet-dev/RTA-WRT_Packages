name: 🚀 KWRT Packages Sync Pipeline

on:
  # ⏰ Daily sync at 02:00 UTC
  schedule:
    - cron: '0 2 * * *'
  
  # 🎯 Manual trigger with advanced options
  workflow_dispatch:
    inputs:
      force_sync:
        description: '⚡ Force sync regardless of changes'
        required: false
        default: false
        type: boolean
      
      sync_mode:
        description: '🔄 Sync mode'
        required: false
        default: 'standard'
        type: choice
        options:
          - standard
          - deep-clean
          - quick-check
          - merge-only
      
      notification_level:
        description: '📢 Notification level'
        required: false
        default: 'normal'
        type: choice
        options:
          - minimal
          - normal
          - verbose

env:
  # 🌟 Configuration
  KWRT_REPO_URL: https://github.com/kiddin9/kwrt-packages
  PACKAGES_DIR: packages
  WORKFLOW_VERSION: "2.1.0"
  MANUAL_PACKAGES_FILE: ".manual-packages"
  SYNC_METADATA_FILE: ".sync-metadata.json"
  
  # 🎨 Styling
  EMOJI_SUCCESS: "✨"
  EMOJI_ERROR: "🔥"
  EMOJI_INFO: "💡"
  EMOJI_SYNC: "⚡"

jobs:
  # 🔍 Pre-flight checks
  preflight:
    name: 🛡️ Pre-flight Validation
    runs-on: ubuntu-latest
    outputs:
      should_proceed: ${{ steps.validation.outputs.proceed }}
      source_available: ${{ steps.validation.outputs.source_ok }}
    
    steps:
    - name: 🔍 Validate Source Repository
      id: validation
      run: |
        echo "🔍 Validating source repository accessibility..."
        
        # Check if source repo is accessible
        if curl -s --head "${{ env.KWRT_REPO_URL }}"; then
          echo "✅ Source repository is accessible"
          echo "source_ok=true" >> $GITHUB_OUTPUT
          echo "proceed=true" >> $GITHUB_OUTPUT
        else
          echo "❌ Source repository is not accessible"
          echo "source_ok=false" >> $GITHUB_OUTPUT
          echo "proceed=false" >> $GITHUB_OUTPUT
        fi

  # 🚀 Main sync job
  sync-packages:
    name: 🚀 Package Synchronization
    runs-on: ubuntu-latest
    needs: preflight
    if: needs.preflight.outputs.should_proceed == 'true'
    
    steps:
    - name: 🎯 Initialize Workspace
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0
        
    - name: 🔧 Configure Environment
      run: |
        echo "🔧 Setting up advanced sync environment..."
        
        # Environment variables
        echo "SOURCE_URL=${{ env.KWRT_REPO_URL }}" >> $GITHUB_ENV
        echo "SYNC_TIMESTAMP=$(date +'%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_ENV
        echo "SYNC_ID=$(date +'%Y%m%d%H%M%S')" >> $GITHUB_ENV
        echo "WORKFLOW_VERSION=${{ env.WORKFLOW_VERSION }}" >> $GITHUB_ENV
        
        # Sync mode configuration
        case "${{ github.event.inputs.sync_mode || 'standard' }}" in
          "deep-clean")
            echo "SYNC_MODE=🧹 Deep Clean" >> $GITHUB_ENV
            echo "CLEAN_STRATEGY=aggressive" >> $GITHUB_ENV
            ;;
          "quick-check")
            echo "SYNC_MODE=⚡ Quick Check" >> $GITHUB_ENV
            echo "CLEAN_STRATEGY=minimal" >> $GITHUB_ENV
            ;;
          "merge-only")
            echo "SYNC_MODE=🔄 Merge Only" >> $GITHUB_ENV
            echo "CLEAN_STRATEGY=merge" >> $GITHUB_ENV
            ;;
          *)
            echo "SYNC_MODE=🔄 Standard" >> $GITHUB_ENV
            echo "CLEAN_STRATEGY=standard" >> $GITHUB_ENV
            ;;
        esac
        
        # Create sync metadata
        echo "📊 Sync Configuration:"
        echo "  🆔 Sync ID: $SYNC_ID"
        echo "  🕒 Timestamp: $(date +'%Y-%m-%d %H:%M:%S UTC')"
        echo "  🔄 Mode: $SYNC_MODE"
        echo "  📦 Version: ${{ env.WORKFLOW_VERSION }}"

    - name: 🏗️ Prepare Workspace & Inventory
      run: |
        echo "🏗️ Preparing synchronized workspace with inventory protection..."
        
        # Create directory structure
        mkdir -p ${{ env.PACKAGES_DIR }}
        mkdir -p .sync-metadata
        
        # Create or load manual packages registry
        if [ ! -f "${{ env.MANUAL_PACKAGES_FILE }}" ]; then
          echo "📝 Creating manual packages registry..."
          echo "# Manual/Contributed Packages Registry" > "${{ env.MANUAL_PACKAGES_FILE }}"
          echo "# Add package names (one per line) that should NOT be removed during sync" >> "${{ env.MANUAL_PACKAGES_FILE }}"
          echo "# Format: package-name or directory-name" >> "${{ env.MANUAL_PACKAGES_FILE }}"
          echo "" >> "${{ env.MANUAL_PACKAGES_FILE }}"
        fi
        
        # Load sync metadata if exists
        if [ -f "${{ env.SYNC_METADATA_FILE }}" ]; then
          echo "📋 Loading existing sync metadata..."
          cp "${{ env.SYNC_METADATA_FILE }}" .sync-metadata/previous-sync.json
        else
          echo "📋 Creating initial sync metadata..."
        fi
        
        # Inventory current packages
        echo "📦 Creating current package inventory..."
        find ${{ env.PACKAGES_DIR }} -maxdepth 1 -not -name '.*' -not -name ${{ env.PACKAGES_DIR }} \
          -printf "%f\n" 2>/dev/null | sort > .sync-metadata/current-packages.txt || echo > .sync-metadata/current-packages.txt
        
        # Load manual packages list (excluding comments and empty lines)
        grep -v '^#\|^$' "${{ env.MANUAL_PACKAGES_FILE }}" 2>/dev/null | sort > .sync-metadata/manual-packages.txt || echo > .sync-metadata/manual-packages.txt
        
        # Show inventory summary
        CURRENT_COUNT=$(wc -l < .sync-metadata/current-packages.txt)
        MANUAL_COUNT=$(wc -l < .sync-metadata/manual-packages.txt)
        
        echo "📊 Package Inventory:"
        echo "  📦 Current packages: $CURRENT_COUNT"
        echo "  🔒 Protected packages: $MANUAL_COUNT"
        
        if [ $MANUAL_COUNT -gt 0 ]; then
          echo "🔒 Protected packages list:"
          sed 's/^/    - /' .sync-metadata/manual-packages.txt
        fi
        
        # Preserve important files
        if [ -f ${{ env.PACKAGES_DIR }}/.gitkeep ]; then
          echo "💾 Preserving .gitkeep file..."
          cp ${{ env.PACKAGES_DIR }}/.gitkeep .sync-metadata/.gitkeep.backup
        fi
        
        # Create sync manifest
        cat > .sync-metadata/sync-manifest.json << EOF
        {
          "sync_id": "${{ env.SYNC_ID }}",
          "timestamp": "${{ env.SYNC_TIMESTAMP }}",
          "source_url": "${{ env.KWRT_REPO_URL }}",
          "workflow_version": "${{ env.WORKFLOW_VERSION }}",
          "sync_mode": "${{ env.SYNC_MODE }}",
          "triggered_by": "${{ github.event_name }}",
          "actor": "${{ github.actor }}",
          "protected_packages_count": $MANUAL_COUNT,
          "current_packages_count": $CURRENT_COUNT
        }
        EOF
        
        echo "✅ Workspace prepared successfully!"

    - name: 📡 Fetch Source Repository
      run: |
        echo "📡 Fetching latest packages from source..."
        echo "🎯 Source: ${{ env.KWRT_REPO_URL }}"
        
        # Download with progress and retry logic
        for attempt in 1 2 3; do
          echo "🔄 Attempt $attempt/3..."
          
          if wget -q --show-progress --progress=bar:force \
            --timeout=30 --tries=3 \
            -O kwrt-packages.zip \
            "${{ env.KWRT_REPO_URL }}/archive/refs/heads/main.zip"; then
            
            echo "✅ Download successful on attempt $attempt!"
            break
          else
            echo "⚠️ Attempt $attempt failed, retrying..."
            [ $attempt -eq 3 ] && exit 1
            sleep 5
          fi
        done
        
        # Verify download
        if [ ! -f kwrt-packages.zip ] || [ ! -s kwrt-packages.zip ]; then
          echo "❌ Download verification failed!"
          exit 1
        fi
        
        echo "📊 Download statistics:"
        ls -lah kwrt-packages.zip
        echo "🔐 File integrity: $(sha256sum kwrt-packages.zip | cut -d' ' -f1)"

    - name: 🎁 Extract and Smart Merge
      run: |
        echo "🎁 Processing downloaded archive with smart merge..."
        
        # Extract with verification
        if ! unzip -q kwrt-packages.zip; then
          echo "❌ Archive extraction failed!"
          exit 1
        fi
        
        # Create staging area
        mkdir -p .sync-staging
        
        echo "📦 Analyzing source packages..."
        cd kwrt-packages-main
        
        # Count and categorize source files
        TOTAL_FILES=$(find . -maxdepth 1 -type f -not -name 'README*' -not -name '.*' | wc -l)
        TOTAL_DIRS=$(find . -maxdepth 1 -type d -not -name '.' -not -name '.github' -not -name '.git' | wc -l)
        
        echo "📊 Source statistics:"
        echo "  📄 Files: $TOTAL_FILES"
        echo "  📁 Directories: $TOTAL_DIRS"
        
        # Move source files to staging
        find . -maxdepth 1 -type f \
          -not -name 'README*' \
          -not -name 'LICENSE*' \
          -not -name '.*' \
          -not -name '*.md' \
          -exec mv {} ../.sync-staging/ \; 2>/dev/null || true
        
        find . -maxdepth 1 -type d \
          -not -name '.' \
          -not -name '.github' \
          -not -name '.git' \
          -exec mv {} ../.sync-staging/ \; 2>/dev/null || true
        
        cd ..
        
        # Create source package inventory
        find .sync-staging -maxdepth 1 -not -name '.*' -not -name .sync-staging \
          -printf "%f\n" 2>/dev/null | sort > .sync-metadata/source-packages.txt || echo > .sync-metadata/source-packages.txt
        
        SOURCE_COUNT=$(wc -l < .sync-metadata/source-packages.txt)
        echo "📦 Source packages: $SOURCE_COUNT"
        
        # Perform smart merge based on strategy
        echo "🔄 Applying ${{ env.CLEAN_STRATEGY }} merge strategy..."
        
        case "${{ env.CLEAN_STRATEGY }}" in
          "aggressive")
            echo "🧹 Performing aggressive merge (removes ALL non-protected packages)..."
            # Remove all packages except protected ones
            while IFS= read -r package; do
              if [ -n "$package" ]; then
                PACKAGE_PATH="${{ env.PACKAGES_DIR }}/$package"
                if [ -e "$PACKAGE_PATH" ]; then
                  # Check if package is protected
                  if ! grep -Fxq "$package" .sync-metadata/manual-packages.txt; then
                    echo "🗑️ Removing unprotected package: $package"
                    rm -rf "$PACKAGE_PATH"
                  else
                    echo "🔒 Preserving protected package: $package"
                  fi
                fi
              fi
            done < .sync-metadata/current-packages.txt
            ;;
            
          "minimal")
            echo "🧹 Performing minimal merge (only updates existing)..."
            # Only update packages that exist in both source and destination
            comm -12 .sync-metadata/source-packages.txt .sync-metadata/current-packages.txt | \
            while IFS= read -r package; do
              if [ -n "$package" ]; then
                # Check if package is protected before updating
                if ! grep -Fxq "$package" .sync-metadata/manual-packages.txt; then
                  echo "🔄 Updating existing package: $package"
                  rm -rf "${{ env.PACKAGES_DIR }}/$package"
                else
                  echo "🔒 Skipping protected package: $package"
                fi
              fi
            done
            ;;
            
          "merge")
            echo "🔄 Performing merge-only (preserves all existing)..."
            # Don't remove anything, only add new packages
            echo "ℹ️ All existing packages will be preserved"
            ;;
            
          *)
            echo "🔄 Performing standard merge (removes only conflicting non-protected)..."
            # Remove packages that exist in destination but check protection
            while IFS= read -r package; do
              if [ -n "$package" ]; then
                PACKAGE_PATH="${{ env.PACKAGES_DIR }}/$package"
                if [ -e "$PACKAGE_PATH" ]; then
                  # Check if package is protected
                  if ! grep -Fxq "$package" .sync-metadata/manual-packages.txt; then
                    # Check if package exists in source (will be replaced)
                    if grep -Fxq "$package" .sync-metadata/source-packages.txt; then
                      echo "🔄 Replacing package: $package"
                      rm -rf "$PACKAGE_PATH"
                    fi
                  else
                    echo "🔒 Preserving protected package: $package"
                  fi
                fi
              fi
            done < .sync-metadata/current-packages.txt
            ;;
        esac
        
        # Move new/updated packages from staging to destination
        echo "📦 Installing source packages..."
        INSTALLED_COUNT=0
        SKIPPED_COUNT=0
        
        if [ -d .sync-staging ]; then
          for item in .sync-staging/*; do
            if [ -e "$item" ] && [ "$item" != ".sync-staging/*" ]; then
              PACKAGE_NAME=$(basename "$item")
              DEST_PATH="${{ env.PACKAGES_DIR }}/$PACKAGE_NAME"
              
              # Check if destination exists and is protected
              if [ -e "$DEST_PATH" ] && grep -Fxq "$PACKAGE_NAME" .sync-metadata/manual-packages.txt 2>/dev/null; then
                echo "🔒 Skipping protected package: $PACKAGE_NAME"
                SKIPPED_COUNT=$((SKIPPED_COUNT + 1))
              else
                echo "✅ Installing package: $PACKAGE_NAME"
                if mv "$item" "$DEST_PATH" 2>/dev/null; then
                  INSTALLED_COUNT=$((INSTALLED_COUNT + 1))
                else
                  echo "⚠️ Failed to move package: $PACKAGE_NAME"
                fi
              fi
            fi
          done
        fi
        
        # Restore preserved files
        if [ -f .sync-metadata/.gitkeep.backup ]; then
          echo "💾 Restoring preserved files..."
          mv .sync-metadata/.gitkeep.backup ${{ env.PACKAGES_DIR }}/.gitkeep
        fi
        
        # Update sync metadata
        cat > "${{ env.SYNC_METADATA_FILE }}" << EOF
        {
          "last_sync_id": "${{ env.SYNC_ID }}",
          "last_sync_timestamp": "${{ env.SYNC_TIMESTAMP }}",
          "last_sync_mode": "${{ env.SYNC_MODE }}",
          "source_packages_count": $SOURCE_COUNT,
          "workflow_version": "${{ env.WORKFLOW_VERSION }}"
        }
        EOF
        
        # Cleanup
        echo "🧹 Cleaning temporary files..."
        rm -rf kwrt-packages.zip kwrt-packages-main .sync-staging
        
        echo "✅ Smart merge completed successfully!"
        echo "📊 Final statistics:"
        echo "  📦 Source packages: $SOURCE_COUNT"

    - name: 🔬 Advanced Change Analysis
      id: analyze
      run: |
        echo "🔬 Performing advanced change analysis..."
        
        # Check for git changes
        git add -A
        
        # Detailed git analysis with error handling
        if git diff --cached --quiet; then
          echo "has_changes=false" >> $GITHUB_OUTPUT
          echo "total_changes=0" >> $GITHUB_OUTPUT
          echo "change_magnitude=none" >> $GITHUB_OUTPUT
          echo "ℹ️ No changes detected - repository is up to date"
        else
          echo "🎯 Changes detected!"
          echo "has_changes=true" >> $GITHUB_OUTPUT
          
          # Initialize counters
          ADDED=0
          MODIFIED=0
          DELETED=0
          RENAMED=0
          UNTRACKED=0
          
          # Safe change counting with error handling
          if git status --porcelain > /tmp/git_status.txt 2>/dev/null; then
            while IFS= read -r line || [ -n "$line" ]; do
              if [ -n "$line" ]; then
                case "${line:0:2}" in
                  "A "|\
                  "AM") ADDED=$((ADDED + 1)) ;;
                  "M "|\
                  "MM"|\
                  " M") MODIFIED=$((MODIFIED + 1)) ;;
                  "D "|\
                  " D") DELETED=$((DELETED + 1)) ;;
                  "R "|\
                  "RM") RENAMED=$((RENAMED + 1)) ;;
                  "??"|\
                  "A ") UNTRACKED=$((UNTRACKED + 1)) ;;
                esac
              fi
            done < /tmp/git_status.txt
            
            # Clean up temp file
            rm -f /tmp/git_status.txt
          else
            # Fallback: count all changes as modified
            MODIFIED=$(git diff --cached --name-only | wc -l)
            echo "⚠️ Using fallback change detection"
          fi
          
          # Calculate total changes safely
          TOTAL_CHANGES=$((ADDED + MODIFIED + DELETED + RENAMED + UNTRACKED))
          
          # Ensure we have at least 1 change if git detected changes
          if [ $TOTAL_CHANGES -eq 0 ]; then
            TOTAL_CHANGES=1
            MODIFIED=1
            echo "⚠️ Adjusted change count to reflect detected modifications"
          fi
          
          # Set outputs safely
          echo "added=${ADDED}" >> $GITHUB_OUTPUT
          echo "modified=${MODIFIED}" >> $GITHUB_OUTPUT
          echo "deleted=${DELETED}" >> $GITHUB_OUTPUT
          echo "renamed=${RENAMED}" >> $GITHUB_OUTPUT
          echo "untracked=${UNTRACKED}" >> $GITHUB_OUTPUT
          echo "total_changes=${TOTAL_CHANGES}" >> $GITHUB_OUTPUT
          
          # Determine change magnitude
          if [ $TOTAL_CHANGES -gt 100 ]; then
            echo "change_magnitude=major" >> $GITHUB_OUTPUT
            echo "🔥 Major changes detected ($TOTAL_CHANGES files)"
          elif [ $TOTAL_CHANGES -gt 20 ]; then
            echo "change_magnitude=moderate" >> $GITHUB_OUTPUT
            echo "⚡ Moderate changes detected ($TOTAL_CHANGES files)"
          else
            echo "change_magnitude=minor" >> $GITHUB_OUTPUT
            echo "✨ Minor changes detected ($TOTAL_CHANGES files)"
          fi
          
          # Enhanced change summary
          echo "📊 Detailed Change Analysis:"
          echo "  ➕ Added: $ADDED"
          echo "  ✏️ Modified: $MODIFIED"
          echo "  ❌ Deleted: $DELETED"
          echo "  🔄 Renamed: $RENAMED"
          echo "  📄 Untracked: $UNTRACKED"
          echo "  📈 Total: $TOTAL_CHANGES"
          
          # Show protected packages info
          PROTECTED_COUNT=$(wc -l < .sync-metadata/manual-packages.txt 2>/dev/null || echo 0)
          echo "  🔒 Protected: $PROTECTED_COUNT packages"
        fi

    - name: 🚀 Smart Commit & Deploy
      if: steps.analyze.outputs.has_changes == 'true' || github.event.inputs.force_sync == 'true'
      run: |
        echo "🚀 Deploying changes with smart commit..."
        
        # Configure git with enhanced identity
        git config --global user.email "noreply@github.com"
        git config --global user.name "🤖 KWRT Sync Bot v${{ env.WORKFLOW_VERSION }}"
        
        # Generate smart commit message
        MAGNITUDE="${{ steps.analyze.outputs.change_magnitude || 'forced' }}"
        TOTAL_CHANGES="${{ steps.analyze.outputs.total_changes || '0' }}"
        PROTECTED_COUNT=$(wc -l < .sync-metadata/manual-packages.txt 2>/dev/null || echo 0)
        
        case "$MAGNITUDE" in
          "major")
            COMMIT_ICON="🔥"
            COMMIT_TYPE="feat"
            ;;
          "moderate")
            COMMIT_ICON="⚡"
            COMMIT_TYPE="update"
            ;;
          "minor")
            COMMIT_ICON="✨"
            COMMIT_TYPE="sync"
            ;;
          "forced")
            COMMIT_ICON="🚀"
            COMMIT_TYPE="force"
            ;;
          *)
            COMMIT_ICON="🔄"
            COMMIT_TYPE="sync"
            ;;
        esac
        
        # Create semantic commit message
        COMMIT_MSG="$COMMIT_ICON $COMMIT_TYPE: KWRT packages sync ($TOTAL_CHANGES changes)

        🎯 Sync Details:
        ├─ 📅 Date: ${{ env.SYNC_TIMESTAMP }}
        ├─ 🆔 ID: ${{ env.SYNC_ID }}
        ├─ 🔄 Mode: ${{ env.SYNC_MODE }}
        ├─ 📦 Version: ${{ env.WORKFLOW_VERSION }}
        ├─ 🔒 Protected: $PROTECTED_COUNT packages
        └─ 📡 Source: ${{ env.KWRT_REPO_URL }}
        
        📊 Change Summary:
        ├─ ➕ Added: ${{ steps.analyze.outputs.added || 0 }}
        ├─ ✏️ Modified: ${{ steps.analyze.outputs.modified || 0 }}
        ├─ ❌ Deleted: ${{ steps.analyze.outputs.deleted || 0 }}
        ├─ 🔄 Renamed: ${{ steps.analyze.outputs.renamed || 0 }}
        └─ 📄 New: ${{ steps.analyze.outputs.untracked || 0 }}
        
        🔒 Protected packages preserved during sync
        🤖 Automated by GitHub Actions
        🔗 Workflow: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
        
        # Add all changes including metadata files
        git add ${{ env.PACKAGES_DIR }}/
        git add "${{ env.SYNC_METADATA_FILE }}"
        git add "${{ env.MANUAL_PACKAGES_FILE }}"
        git commit -m "$COMMIT_MSG"
        git push
        
        echo "✅ Changes deployed successfully!"

    - name: 📊 Generate Advanced Report
      run: |
        echo "📊 Generating comprehensive sync report..."
        
        # Load statistics
        PROTECTED_COUNT=$(wc -l < .sync-metadata/manual-packages.txt 2>/dev/null || echo 0)
        CURRENT_COUNT=$(find ${{ env.PACKAGES_DIR }} -maxdepth 1 -not -name '.*' -not -name ${{ env.PACKAGES_DIR }} | wc -l)
        
        # Determine status
        if [[ "${{ steps.analyze.outputs.has_changes }}" == "true" ]]; then
          STATUS_ICON="✅"
          STATUS_TEXT="SUCCESS"
          STATUS_COLOR="green"
        elif [[ "${{ github.event.inputs.force_sync }}" == "true" ]]; then
          STATUS_ICON="🚀"
          STATUS_TEXT="FORCED"
          STATUS_COLOR="blue"
        else
          STATUS_ICON="ℹ️"
          STATUS_TEXT="NO CHANGES"
          STATUS_COLOR="gray"
        fi
        
        # Generate advanced report
        cat >> $GITHUB_STEP_SUMMARY << EOF
        # 🚀 KWRT Packages Sync Report v${{ env.WORKFLOW_VERSION }}
        
        ## $STATUS_ICON Status: **$STATUS_TEXT**
        
        ### 📋 Sync Information
        
        | 🏷️ Property | 📝 Value |
        |-------------|----------|
        | **🆔 Sync ID** | \`${{ env.SYNC_ID }}\` |
        | **📅 Timestamp** | \`${{ env.SYNC_TIMESTAMP }}\` |
        | **🔄 Mode** | ${{ env.SYNC_MODE }} |
        | **📦 Version** | \`${{ env.WORKFLOW_VERSION }}\` |
        | **👤 Triggered By** | \`${{ github.actor }}\` |
        | **🎯 Event** | \`${{ github.event_name }}\` |
        | **📡 Source** | [${{ env.KWRT_REPO_URL }}](${{ env.KWRT_REPO_URL }}) |
        | **🔗 Workflow** | [Run #${{ github.run_id }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) |
        
        ### 🔒 Package Protection Status
        
        | 📊 Category | 🔢 Count | 📝 Description |
        |-------------|----------|----------------|
        | **🔒 Protected Packages** | \`$PROTECTED_COUNT\` | Manual/contributed packages preserved |
        | **📦 Total Packages** | \`$CURRENT_COUNT\` | All packages in repository |
        | **⚡ Sync Eligible** | \`$((CURRENT_COUNT - PROTECTED_COUNT))\` | Packages managed by sync |
        
        EOF
        
        # Show protected packages if any
        if [ $PROTECTED_COUNT -gt 0 ]; then
          cat >> $GITHUB_STEP_SUMMARY << EOF
        ### 🔒 Protected Packages List
        
        EOF
          while IFS= read -r package; do
            if [ -n "$package" ]; then
              echo "- \`$package\`" >> $GITHUB_STEP_SUMMARY
            fi
          done < .sync-metadata/manual-packages.txt
          
          cat >> $GITHUB_STEP_SUMMARY << EOF
        
        EOF
        fi
        
        # Add change details if applicable
        if [[ "${{ steps.analyze.outputs.has_changes }}" == "true" ]]; then
          MAGNITUDE="${{ steps.analyze.outputs.change_magnitude }}"
          
          case "$MAGNITUDE" in
            "major") MAGNITUDE_ICON="🔥"; MAGNITUDE_DESC="Major Update" ;;
            "moderate") MAGNITUDE_ICON="⚡"; MAGNITUDE_DESC="Moderate Update" ;;
            "minor") MAGNITUDE_ICON="✨"; MAGNITUDE_DESC="Minor Update" ;;
            *) MAGNITUDE_ICON="🔄"; MAGNITUDE_DESC="Standard Update" ;;
          esac
          
          cat >> $GITHUB_STEP_SUMMARY << EOF
        ### $MAGNITUDE_ICON Change Analysis: **$MAGNITUDE_DESC**
        
        | 📊 Change Type | 🔢 Count | 📈 Impact |
        |----------------|----------|-----------|
        | ➕ **Added** | \`${{ steps.analyze.outputs.added || 0 }}\` | New packages/files |
        | ✏️ **Modified** | \`${{ steps.analyze.outputs.modified || 0 }}\` | Updated content |
        | ❌ **Deleted** | \`${{ steps.analyze.outputs.deleted || 0 }}\` | Removed items |
        | 🔄 **Renamed** | \`${{ steps.analyze.outputs.renamed || 0 }}\` | Restructured files |
        | 📄 **New Files** | \`${{ steps.analyze.outputs.untracked || 0 }}\` | Fresh additions |
        | **🎯 Total Changes** | **\`${{ steps.analyze.outputs.total_changes || 0 }}\`** | **Overall impact** |
        
        EOF
        fi
        
        # Add instructions for managing protected packages
        cat >> $GITHUB_STEP_SUMMARY << EOF
        ### 🛠️ Managing Protected Packages
        
        To protect packages from being removed during sync:
        
        1. **Add to protection list**: Edit \`${{ env.MANUAL_PACKAGES_FILE }}\` file
        2. **Add package name**: One package name per line (e.g., \`my-custom-package\`)
        3. **Commit changes**: Protected packages list is version controlled
        
        **Example \`${{ env.MANUAL_PACKAGES_FILE }}\`:**
        \`\`\`
        # Manual/Contributed Packages Registry
        my-custom-package
        contributed-tool
        local-modification
        \`\`\`
        
        ---
        
        ### 🎯 Quick Actions
        
        - 🔄 [View Source Repository](${{ env.KWRT_REPO_URL }})
        - 📦 [Browse Packages](${{ github.server_url }}/${{ github.repository }}/tree/main/${{ env.PACKAGES_DIR }})
        - 🔒 [Edit Protected Packages](${{ github.server_url }}/${{ github.repository }}/edit/main/${{ env.MANUAL_PACKAGES_FILE }})
        - 📊 [Workflow History](${{ github.server_url }}/${{ github.repository }}/actions/workflows/sync-kwrt.yml)
        - 🚀 [Manual Sync](${{ github.server_url }}/${{ github.repository }}/actions/workflows/sync-kwrt.yml)
        
        ---
        
        <div align="center">
        
        **🤖 Powered by GitHub Actions** • **⚡ KWRT Sync Bot v${{ env.WORKFLOW_VERSION }}**
        
        *Intelligent package synchronization with contribution protection*
        
        </div>
        EOF

    - name: 🎉 Sync Complete
      run: |
        echo "🎉 KWRT Packages sync pipeline completed successfully!"
        echo ""
        echo "📊 Final Summary:"
        echo "┌─────────────────────────────────────────────────────────────┐"
        echo "│                    🚀 SYNC COMPLETED                        │"
        echo "├─────────────────────────────────────────────────────────────┤"
        echo "│ 🆔 Sync ID: ${{ env.SYNC_ID }}                   │"
        echo "│ 📅 Date: ${{ env.SYNC_TIMESTAMP }}                    │"
        echo "│ 🔄 Mode: ${{ env.SYNC_MODE }}                           │"
        echo "│ 📦 Version: ${{ env.WORKFLOW_VERSION }}                            │"
        echo "│ 🎯 Status: $([ "${{ steps.analyze.outputs.has_changes }}" == "true" ] && echo "✅ Updated" || echo "ℹ️ No changes")                                 │"
        echo "│ 📊 Changes: ${{ steps.analyze.outputs.total_changes || 0 }} files affected                          │"
        echo "│ 🔒 Protected: $(wc -l < .sync-metadata/manual-packages.txt 2>/dev/null || echo 0) packages preserved                       │"
        echo "└─────────────────────────────────────────────────────────────┘"
        echo ""
        echo "🔒 Manual/contributed packages are preserved during sync"
        echo "📝 To protect packages: edit ${{ env.MANUAL_PACKAGES_FILE }}"
        echo "🚀 Next sync scheduled for tomorrow at 02:00 UTC"
        echo "⚡ Manual sync available via workflow dispatch"