name: üöÄ OpenWRT Package Builder & Release Pipeline

on:
  workflow_dispatch:
    inputs:
      force_cleanup:
        description: 'üßπ Force repository cleanup'
        required: false
        default: true
        type: boolean
      build_target:
        description: 'üéØ Build target'
        required: false
        default: 'all'
        type: choice
        options:
          - all
          - stable-only
          - snapshot-only
          - custom
      custom_arch:
        description: 'üèóÔ∏è Custom architecture (if custom selected)'
        required: false
        type: string
      custom_branch:
        description: 'üåø Custom branch (if custom selected)'
        required: false
        type: string
      package:
        description: 'üì¶ Optional: Name of the single package to build (e.g., my-package)'
        required: false
        type: string
  schedule:
    - cron: '0 2 * * 0'  # Weekly build on Sunday at 2 AM UTC

env:
  SOURCE_REPO: rizkikotet-dev/RTA-WRT_Packages
  MAX_REPO_SIZE_GB: 2
  BATCH_SIZE: 100
  CACHE_VERSION: v2
  NODE_VERSION: '20'

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  prepare:
    name: üîç Prepare Build Matrix
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.matrix.outputs.matrix }}
      should_build: ${{ steps.check.outputs.should_build }}
      total_jobs: ${{ steps.matrix.outputs.total_jobs }}
    
    steps:
      - name: üìã Checkout source code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: üîç Check if build is needed
        id: check
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "should_build=true" >> $GITHUB_OUTPUT
          elif [[ "${{ github.event_name }}" == "schedule" ]]; then
            echo "should_build=true" >> $GITHUB_OUTPUT
          else
            echo "should_build=false" >> $GITHUB_OUTPUT
          fi

      - name: üèóÔ∏è Generate build matrix
        id: matrix
        run: |
          set -euo pipefail
          
          custom_arch="${{ github.event.inputs.custom_arch || '' }}"
          custom_branch="${{ github.event.inputs.custom_branch || '' }}"
          build_target="${{ github.event.inputs.build_target || 'all' }}"
          
          echo "Build target: $build_target"
          echo "Custom arch: $custom_arch"
          echo "Custom branch: $custom_branch"

          # Define architectures
          declare -a archs=(
            "aarch64_cortex-a53"
            "aarch64_cortex-a72" 
            "aarch64_cortex-a76"
            "aarch64_generic"
            "x86_64"
          )
          
          # Define branches based on build target
          case "$build_target" in
            "stable-only")
              declare -a branches=("openwrt-23.05" "openwrt-24.10")
              ;;
            "snapshot-only")
              declare -a branches=("SNAPSHOT")
              ;;
            "custom")
              if [[ -n "$custom_arch" && -n "$custom_branch" ]]; then
                archs=("$custom_arch")
                declare -a branches=("$custom_branch")
              else
                echo "‚ùå Custom arch and branch must be specified for custom build"
                exit 1
              fi
              ;;
            *)
              declare -a branches=("openwrt-23.05" "openwrt-24.10" "SNAPSHOT")
              ;;
          esac
          
          # Generate matrix
          matrix_json='{"include":['
          total_jobs=0
          
          for arch in "${archs[@]}"; do
            for branch in "${branches[@]}"; do
              if [[ $total_jobs -gt 0 ]]; then
                matrix_json+=','
              fi
              matrix_json+="{\"arch\":\"$arch\",\"branch\":\"$branch\",\"stable\":$([ "$branch" != "SNAPSHOT" ] && echo "true" || echo "false")}"
              total_jobs=$((total_jobs + 1))
            done
          done
          
          matrix_json+=']}'
          
          echo "matrix=$matrix_json" >> $GITHUB_OUTPUT
          echo "total_jobs=$total_jobs" >> $GITHUB_OUTPUT
          
          echo "üéØ Generated matrix for $total_jobs jobs"
          echo "$matrix_json" | jq '.'

  build:
    name: üèóÔ∏è Build ${{ matrix.arch }} ‚Ä¢ ${{ matrix.branch }}
    runs-on: ubuntu-latest
    needs: prepare
    if: needs.prepare.outputs.should_build == 'true'
    continue-on-error: true
    
    strategy:
      fail-fast: false
      max-parallel: 6
      matrix: ${{ fromJson(needs.prepare.outputs.matrix) }}

    steps:
      - name: üöÄ Starting build
        run: |
          echo "::notice title=Build Started::üèóÔ∏è Building packages for ${{ matrix.arch }} on ${{ matrix.branch }}"
          echo "### üèóÔ∏è Build Configuration" >> $GITHUB_STEP_SUMMARY
          echo "- **Architecture**: ${{ matrix.arch }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch**: ${{ matrix.branch }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Stable**: ${{ matrix.stable }}" >> $GITHUB_STEP_SUMMARY

      - name: üì• Checkout source code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          lfs: true

      - name: üíæ Cache OpenWRT SDK
        uses: actions/cache@v4
        with:
          path: |
            openwrt-sdk-*
            dl/
          key: openwrt-sdk-${{ matrix.arch }}-${{ matrix.branch }}-${{ env.CACHE_VERSION }}
          restore-keys: |
            openwrt-sdk-${{ matrix.arch }}-${{ matrix.branch }}-
            openwrt-sdk-${{ matrix.arch }}-

      - name: üîß Setup build environment
        run: |
          echo "::group::Installing dependencies"
          sudo apt-get update -qq
          sudo apt-get install -y --no-install-recommends \
            build-essential libncurses5-dev zlib1g-dev gawk git \
            gettext libssl-dev xsltproc wget unzip python3 rsync \
            file python3-minimal libpython3-stdlib \
            ca-certificates curl jq zstd
          echo "::endgroup::"
          
          echo "::group::System information"
          echo "CPU cores: $(nproc)"
          echo "Memory: $(free -h | head -2)"
          echo "Disk space: $(df -h | head -2)"
          echo "::endgroup::"

      - name: üì¶ Validate package existence
        if: github.event.inputs.package != ''
        run: |
          PACKAGE="${{ github.event.inputs.package }}"
          if [ -d "./packages/$PACKAGE" ] && [ -f "./packages/$PACKAGE/Makefile" ]; then
            echo "üîç Package '$PACKAGE' found"
          else
            echo "‚ùå Package '$PACKAGE' not found in packages/ directory"
            exit 1
          fi

      - name: üèóÔ∏è Build packages with OpenWRT SDK (with input)
        if: ${{ github.event.inputs.package != '' }}
        uses: openwrt/gh-action-sdk@main
        env:
          ARCH: ${{ matrix.arch }}
          BRANCH: ${{ matrix.branch }}
          FEEDNAME: custom_packages
          FEED_DIR: ./packages/
          INDEX: 1
          NO_REFRESH_CHECK: true
          IGNORE_ERRORS: true
          PACKAGES: ${{ github.event.inputs.package }}

      - name: üèóÔ∏è Build packages with OpenWRT SDK (no input)
        if: ${{ github.event.inputs.package == '' }}
        uses: openwrt/gh-action-sdk@main
        env:
          ARCH: ${{ matrix.arch }}
          BRANCH: ${{ matrix.branch }}
          FEEDNAME: custom_packages
          FEED_DIR: ./packages/
          INDEX: 1
          NO_REFRESH_CHECK: true
          IGNORE_ERRORS: true

      - name: üîç Validate build artifacts
        id: validate
        run: |
          BUILD_DIR="bin/packages/${{ matrix.arch }}/custom_packages"
          
          if [[ ! -d "$BUILD_DIR" ]]; then
            echo "::warning::‚ùå No packages were built for ${{ matrix.arch }} (${{ matrix.branch }})"
            echo "has_packages=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          PACKAGE_COUNT=$(find "$BUILD_DIR" -name "*.ipk" -o -name "*.apk" | wc -l)
          
          if [[ $PACKAGE_COUNT -eq 0 ]]; then
            echo "::warning::üì¶ No package files found in build directory"
            echo "has_packages=false" >> $GITHUB_OUTPUT
          else
            echo "::notice::‚úÖ Successfully built $PACKAGE_COUNT packages"
            echo "has_packages=true" >> $GITHUB_OUTPUT
            echo "package_count=$PACKAGE_COUNT" >> $GITHUB_OUTPUT
          fi

      - name: üì¶ Organize and package artifacts
        if: steps.validate.outputs.has_packages == 'true'
        run: |
          echo "::group::üìÅ Organizing packages"
          
          OUTPUT_DIR="releases/${{ matrix.branch }}/${{ matrix.arch }}"
          mkdir -p "$OUTPUT_DIR"
          
          # Copy packages with verification
          BUILD_DIR="bin/packages/${{ matrix.arch }}/custom_packages"
          if [[ -d "$BUILD_DIR" ]]; then
            rsync -av --stats "$BUILD_DIR/" "$OUTPUT_DIR/"
          fi
          
          # Generate enhanced manifest with metadata
          {
            echo "# üì¶ Package Manifest"
            echo ""
            echo "| Field | Value |"
            echo "|-------|-------|"
            echo "| Architecture | \`${{ matrix.arch }}\` |"
            echo "| OpenWRT Version | \`${{ matrix.branch }}\` |"
            echo "| Build Date | $(date -u '+%Y-%m-%d %H:%M:%S UTC') |"
            echo "| Build ID | \`${{ github.run_id }}\` |"
            echo "| Commit SHA | \`${{ github.sha }}\` |"
            echo "| Package Count | ${{ steps.validate.outputs.package_count }} |"
            echo ""
            echo "## üìã Package List"
            echo ""
            
            find "$OUTPUT_DIR" -name "*.ipk" -o -name "*.apk" | sort | while read -r pkg; do
              pkg_name=$(basename "$pkg")
              pkg_size=$(stat -c%s "$pkg" | numfmt --to=iec)
              echo "- **$pkg_name** ($pkg_size)"
            done
            
            echo ""
            echo "## üîß Installation"
            echo ""
            echo "\`\`\`bash"
            echo "# Add repository"
            echo "echo 'src/gz custom https://github.com/${{ github.repository }}/raw/releases/packages/${{ matrix.branch }}/${{ matrix.arch }}' >> /etc/opkg/customfeeds.conf"
            echo ""
            echo "# Update and install"
            echo "opkg update"
            echo "opkg install <package_name>"
            echo "\`\`\`"
          } > "$OUTPUT_DIR/README.md"
          
          echo "::endgroup::"
          
          echo "::group::üìä Build statistics"
          echo "Total packages: ${{ steps.validate.outputs.package_count }}"
          echo "Total size: $(du -sh "$OUTPUT_DIR" | cut -f1)"
          echo "::endgroup::"

      - name: üóúÔ∏è Create optimized archive
        if: steps.validate.outputs.has_packages == 'true'
        run: |
          ARCHIVE_NAME="packages_${{ matrix.arch }}-${{ matrix.branch }}.tar.zst"
          
          # Use zstd for better compression
          tar -cf - -C "releases/${{ matrix.branch }}/${{ matrix.arch }}" . | \
            zstd -T0 -19 > "$ARCHIVE_NAME"
          
          echo "üì¶ Archive created: $ARCHIVE_NAME ($(stat -c%s "$ARCHIVE_NAME" | numfmt --to=iec))"

      - name: üì§ Upload build artifacts
        if: steps.validate.outputs.has_packages == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: packages_${{ matrix.arch }}-${{ matrix.branch }}
          path: |
            releases/${{ matrix.branch }}/${{ matrix.arch }}/**
            packages_${{ matrix.arch }}-${{ matrix.branch }}.tar.zst
          retention-days: 30
          compression-level: 6

      - name: üìä Update step summary
        if: always()
        run: |
          echo "### üìä Build Results" >> $GITHUB_STEP_SUMMARY
          if [[ "${{ steps.validate.outputs.has_packages }}" == "true" ]]; then
            echo "‚úÖ **Success**: Built ${{ steps.validate.outputs.package_count }} packages" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå **Failed**: No packages built" >> $GITHUB_STEP_SUMMARY
          fi

  release:
    name: üöÄ Release & Deploy Packages
    needs: [prepare, build]
    runs-on: ubuntu-latest
    if: always() && needs.prepare.outputs.should_build == 'true'
    permissions:
      contents: write
      actions: read

    steps:
      - name: üéØ Release initialization
        run: |
          echo "::notice title=Release Started::üöÄ Starting package release process"
          echo "### üöÄ Release Pipeline" >> $GITHUB_STEP_SUMMARY
          echo "- **Total jobs**: ${{ needs.prepare.outputs.total_jobs }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Trigger**: ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY

      - name: üì• Checkout releases branch
        uses: actions/checkout@v4
        with:
          ref: releases
          fetch-depth: 1
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: üîß Setup release environment
        run: |
          # Install dependencies
          sudo apt-get update -qq
          sudo apt-get install -y --no-install-recommends git jq zstd pv

          # Configure Git
          git config user.email "actions@github.com"
          git config user.name "ü§ñ OpenWRT Package Bot"
          git config pull.rebase true

      - name: üì• Download all build artifacts
        uses: actions/download-artifact@v4
        with:
          path: ./temp-artifacts

      - name: üîÑ Process and organize packages
        if: always()
        run: |
          echo "::group::üîÑ Processing artifacts"
          
          mkdir -p packages
          total_processed=0
          
          for artifact_dir in ./temp-artifacts/packages_*; do
            [[ -d "$artifact_dir" ]] || continue
            
            artifact_name=$(basename "$artifact_dir")
            echo "üìÅ Processing: $artifact_name"
            
            # Parse artifact metadata
            metadata=${artifact_name#packages_}
            arch=${metadata%-*}
            branch=${metadata##*-}
            
            echo "  üèóÔ∏è Architecture: $arch"
            echo "  üåø Branch: $branch"
            
            # Create target structure
            target_dir="packages/$branch/$arch"
            mkdir -p "$target_dir"
            
            # Find and process packages
            for search_path in \
              "$artifact_dir/releases/$branch/$arch" \
              "$artifact_dir"; do
              
              if [[ -d "$search_path" ]]; then
                echo "  üì¶ Processing packages from: $search_path"
                
                # Copy packages efficiently
                find "$search_path" -name "*.ipk" -o -name "*.apk" | while read -r package; do
                  if [[ -f "$package" ]]; then
                    cp "$package" "$target_dir/"
                    ((total_processed++))
                  fi
                done
                
                # Copy metadata
                [[ -f "$search_path/README.md" ]] && cp "$search_path/README.md" "$target_dir/"
                [[ -f "$search_path/Packages" ]] && cp "$search_path/Packages" "$target_dir/"
                
                break
              fi
            done
            
            # Verify processing
            processed_count=$(find "$target_dir" -name "*.ipk" -o -name "*.apk" 2>/dev/null | wc -l)
            echo "  ‚úÖ Processed $processed_count packages for $arch/$branch"
          done
          
          echo "::endgroup::"
          echo "üìä Total packages processed: $total_processed"

      - name: üîÑ Process and organize packages
        if: steps.download.outputs.success == 'true'
        run: |
          echo "::group::üîÑ Processing artifacts"
          
          mkdir -p packages
          total_processed=0
          
          for artifact_dir in ./temp-artifacts/packages_*; do
            [[ -d "$artifact_dir" ]] || continue
            
            artifact_name=$(basename "$artifact_dir")
            echo "üìÅ Processing: $artifact_name"
            
            # Parse artifact metadata
            metadata=${artifact_name#packages_}
            arch=${metadata%-*}
            branch=${metadata##*-}
            
            echo "  üèóÔ∏è Architecture: $arch"
            echo "  üåø Branch: $branch"
            
            # Create target structure
            target_dir="packages/$branch/$arch"
            mkdir -p "$target_dir"
            
            # Find and process packages
            for search_path in \
              "$artifact_dir/releases/$branch/$arch" \
              "$artifact_dir"; do
              
              if [[ -d "$search_path" ]]; then
                echo "  üì¶ Processing packages from: $search_path"
                
                # Copy packages efficiently
                find "$search_path" -name "*.ipk" -o -name "*.apk" | while read -r package; do
                  if [[ -f "$package" ]]; then
                    cp "$package" "$target_dir/"
                    ((total_processed++))
                  fi
                done
                
                # Copy metadata
                [[ -f "$search_path/README.md" ]] && cp "$search_path/README.md" "$target_dir/"
                [[ -f "$search_path/Packages" ]] && cp "$search_path/Packages" "$target_dir/"
                
                break
              fi
            done
            
            # Verify processing
            processed_count=$(find "$target_dir" -name "*.ipk" -o -name "*.apk" 2>/dev/null | wc -l)
            echo "  ‚úÖ Processed $processed_count packages for $arch/$branch"
          done
          
          echo "::endgroup::"
          echo "üìä Total packages processed: $total_processed"

      - name: üßπ Intelligent repository cleanup
        run: |
          echo "::group::üßπ Repository maintenance"
          
          current_size_gb=$(du -sb . 2>/dev/null | awk '{print int($1/1024/1024/1024)}' || echo "0")
          echo "üìè Current repository size: ${current_size_gb}GB"
          
          if [[ $current_size_gb -gt $MAX_REPO_SIZE_GB ]] || [[ "${{ github.event.inputs.force_cleanup }}" == "true" ]]; then
            echo "üßπ Cleanup required (size: ${current_size_gb}GB, limit: ${MAX_REPO_SIZE_GB}GB)"
            
            # Strategy 1: Remove duplicate packages (keep latest)
            echo "  üîÑ Deduplicating packages..."
            find packages -name "*.ipk" -o -name "*.apk" 2>/dev/null | \
              sed 's/_[^_]*\.(ipk|apk)$//' | sort | uniq -d | \
              while read -r base_name; do
                find packages -name "${base_name}_*" 2>/dev/null | sort -V | head -n -1 | xargs rm -f 2>/dev/null || true
              done
            
            # Strategy 2: Remove oldest snapshots first
            echo "  üóëÔ∏è Removing old snapshots..."
            find packages/SNAPSHOT -name "*.ipk" -o -name "*.apk" 2>/dev/null | \
              head -n -$((MAX_REPO_SIZE_GB * 200)) | xargs rm -f 2>/dev/null || true
            
            # Strategy 3: Clean empty directories
            find packages -type d -empty -delete 2>/dev/null || true
            
            new_size_gb=$(du -sb . 2>/dev/null | awk '{print int($1/1024/1024/1024)}' || echo "0")
            echo "  üìâ Size after cleanup: ${new_size_gb}GB"
          fi
          
          echo "::endgroup::"

      - name: üìä Generate repository metadata
        id: generate_metadata
        run: |
          echo "::group::üìä Generating metadata"
          
          # Calculate comprehensive statistics
          total_packages=$(find packages -name "*.ipk" -o -name "*.apk" 2>/dev/null | wc -l)
          total_branches=$(find packages -mindepth 1 -maxdepth 1 -type d 2>/dev/null | wc -l)
          total_archs=$(find packages -mindepth 2 -maxdepth 2 -type d 2>/dev/null | wc -l)
          repo_size_mb=$(du -sm packages 2>/dev/null | cut -f1 || echo "0")
          
          # Store metadata for later use
          echo "total_packages=$total_packages" >> $GITHUB_OUTPUT
          echo "total_branches=$total_branches" >> $GITHUB_OUTPUT
          echo "total_archs=$total_archs" >> $GITHUB_OUTPUT
          echo "repo_size_mb=$repo_size_mb" >> $GITHUB_OUTPUT
          
          # Create comprehensive repository metadata
          cat > packages/repository.json <<EOF
          {
            "repository": {
              "name": "üöÄ OpenWRT Custom Packages",
              "description": "Pre-built OpenWRT packages for multiple architectures and versions",
              "version": "2.0.0",
              "updated": "$(date -u '+%Y-%m-%dT%H:%M:%SZ')",
              "statistics": {
                "total_packages": $total_packages,
                "total_branches": $total_branches,
                "total_architectures": $total_archs,
                "repository_size_mb": $repo_size_mb,
                "last_build_packages": ${{ steps.download.outputs.total_packages || 0 }}
              },
              "branches": $(find packages -mindepth 1 -maxdepth 1 -type d 2>/dev/null | xargs -r -n1 basename | sort | jq -R . | jq -s . || echo '[]'),
              "architectures": $(find packages -mindepth 2 -maxdepth 2 -type d 2>/dev/null | xargs -r -n1 dirname | xargs -r -n1 basename | sort -u | jq -R . | jq -s . || echo '[]'),
              "build_info": {
                "workflow_run_id": "${{ github.run_id }}",
                "commit_sha": "${{ github.sha }}",
                "trigger": "${{ github.event_name }}",
                "source_repository": "$SOURCE_REPO"
              },
              "usage": {
                "opkg_source": "src/gz custom_packages https://raw.githubusercontent.com/${{ github.repository }}/releases/packages/[BRANCH]/[ARCH]",
                "browse_url": "https://github.com/${{ github.repository }}/tree/releases/packages"
              }
            }
          }
          EOF
          
          # Generate README
          {
            echo "# üöÄ OpenWRT Custom Packages Repository"
            echo ""
            echo "## üìä Repository Statistics"
            echo ""
            echo "- **Total Packages**: $total_packages"
            echo "- **Architectures**: $total_archs"
            echo "- **Branches**: $total_branches"
            echo "- **Repository Size**: ${repo_size_mb}MB"
            echo ""
            echo "> Last updated: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
            echo ""
            
            # Generate branch information
            echo "## üåø Supported OpenWRT Versions"
            echo ""
            
            for branch_dir in packages/*; do
              if [[ -d "$branch_dir" ]]; then
                branch_name=$(basename "$branch_dir")
                branch_packages=$(find "$branch_dir" -name "*.ipk" -o -name "*.apk" 2>/dev/null | wc -l)
                
                echo "### $branch_name"
                echo ""
                echo "| Architecture | Packages |"
                echo "|--------------|----------|"
                
                for arch_dir in "$branch_dir"/*; do
                  if [[ -d "$arch_dir" ]]; then
                    arch_name=$(basename "$arch_dir")
                    arch_packages=$(find "$arch_dir" -name "*.ipk" -o -name "*.apk" 2>/dev/null | wc -l)
                    if [[ $arch_packages -gt 0 ]]; then
                      echo "| \`$arch_name\` | $arch_packages |"
                    fi
                  fi
                done
                echo ""
              fi
            done
            
            echo "## üöÄ Quick Start"
            echo ""
            echo "\`\`\`bash"
            echo "# Add repository (replace [BRANCH] and [ARCH] with your values)"
            echo "echo 'src/gz custom_packages https://raw.githubusercontent.com/${{ github.repository }}/releases/packages/[BRANCH]/[ARCH]' >> /etc/opkg/customfeeds.conf"
            echo ""
            echo "# Update package lists"
            echo "opkg update"
            echo ""
            echo "# Install packages"
            echo "opkg install [package_name]"
            echo "\`\`\`"
            echo ""
            echo "Built with ‚ù§Ô∏è using GitHub Actions"
          } > README.md
          
          echo "::endgroup::"
          echo "‚úÖ Generated repository metadata"

      - name: üöÄ Commit and deploy changes
        run: |
          echo "::group::üöÄ Deploying changes"
          
          # Check for changes
          if git diff --quiet && git diff --cached --quiet && [[ -z $(git ls-files --others --exclude-standard) ]]; then
            echo "‚ÑπÔ∏è No changes to commit"
            exit 0
          fi
          
          # Add all changes
          git add .
          
          # Get package count for commit message
          package_count=$(find packages -name "*.ipk" -o -name "*.apk" 2>/dev/null | wc -l)
          
          # Commit changes
          git commit -m "üì¶ Update packages - Build ${{ github.run_id }}" \
                    -m "üïê Updated: $(date -u '+%Y-%m-%d %H:%M:%S UTC')" \
                    -m "üìä Total packages: $package_count" \
                    -m "üèóÔ∏è Build ID: ${{ github.run_id }}" \
                    -m "üåø Source: $SOURCE_REPO" || {
            echo "‚ÑπÔ∏è No changes to commit"
            exit 0
          }
          
          echo "::endgroup::"
          
          echo "::group::üåê Pushing to GitHub"
          
          # Enhanced push with retry
          max_retries=3
          retry_delay=10
          
          for attempt in $(seq 1 $max_retries); do
            echo "üöÄ Push attempt $attempt/$max_retries"
            
            if git push origin releases; then
              echo "‚úÖ Successfully pushed on attempt $attempt"
              break
            else
              echo "‚ö†Ô∏è Push attempt $attempt failed"
              
              if [[ $attempt -eq $max_retries ]]; then
                echo "‚ùå All push attempts failed"
                exit 1
              fi
              
              echo "‚è≥ Waiting ${retry_delay}s before retry..."
              sleep $retry_delay
              
              # Try to pull and resolve conflicts
              git pull --rebase origin releases || {
                echo "Failed to rebase, trying merge strategy"
                git rebase --abort 2>/dev/null || true
                git pull --no-rebase origin releases
              }
            fi
          done
          
          echo "::endgroup::"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: üéâ Generate success summary
        if: success()
        run: |
          total_packages=$(find packages -name "*.ipk" -o -name "*.apk" 2>/dev/null | wc -l)
          repo_size=$(du -sh packages 2>/dev/null | cut -f1 || echo "0B")
          
          cat >> $GITHUB_STEP_SUMMARY <<EOF
          ## üéâ Release Completed Successfully!
          
          ### üìä Final Statistics
          - **Total Packages**: $total_packages
          - **Repository Size**: $repo_size
          - **Commit SHA**: \`${{ github.sha }}\`
          
          ### üîó Quick Links
          - üì¶ [Browse Packages](../../tree/releases/packages)
          - üìã [Repository Metadata](../../blob/releases/packages/repository.json)
          - üèÉ [View Workflow](../../actions/runs/${{ github.run_id }})
          
          ---
          *Generated on $(date -u '+%Y-%m-%d %H:%M:%S UTC') by GitHub Actions*
          EOF

  cleanup:
    name: üßπ Cleanup & Maintenance
    runs-on: ubuntu-latest
    needs: [build, release]
    if: always()
    
    steps:
      - name: üìä Workflow summary
        run: |
          echo "### üèÅ Workflow Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Job | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-----|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Build | ${{ needs.build.result == 'success' && '‚úÖ Success' || needs.build.result == 'failure' && '‚ùå Failed' || '‚è≠Ô∏è Skipped' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Release | ${{ needs.release.result == 'success' && '‚úÖ Success' || needs.release.result == 'failure' && '‚ùå Failed' || '‚è≠Ô∏è Skipped' }} |" >> $GITHUB_STEP_SUMMARY

      - name: üîî Notification on failure
        if: failure()
        run: |
          echo "::error title=Workflow Failed::‚ùå The OpenWRT package build workflow has failed"
          echo "Please check the logs and fix any issues before the next scheduled run."