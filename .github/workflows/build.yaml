name: Build and Release OpenWRT Packages

on:
  workflow_dispatch:
    inputs:
      force_cleanup:
        description: 'Force repository cleanup'
        required: false
        default: 'true'
        type: boolean

env:
  SOURCE_REPO: rizkikotet-dev/RTA-WRT_Packages
  MAX_REPO_SIZE_MB: 900
  BATCH_SIZE: 50

jobs:
  build:
    name: Build ${{ matrix.arch }} (${{ matrix.branch }})
    runs-on: ubuntu-latest
    continue-on-error: true
    strategy:
      fail-fast: false
      matrix:
        arch:
          - arm_cortex-a5_vfpv4
          - arm_cortex-a7_neon-vfpv4
          - arm_cortex-a8_vfpv3
          - arm_cortex-a9
          - arm_cortex-a9_vfpv3-d16
          - arm_cortex-a9_neon
          - arm_cortex-a15_neon-vfpv4
          - aarch64_cortex-a53
          - aarch64_cortex-a72
          - aarch64_cortex-a76
          - aarch64_generic
          - mips_24kc
          - mips_4kec
          - mips_mips32
          - mipsel_24kc
          - mipsel_24kc_24kf
          - mipsel_74kc
          - mipsel_mips32
          - mips64_octeonplus
          - i386_pentium4
          - x86_64
        branch:
          - openwrt-23.05
          - openwrt-24.10
          - SNAPSHOT
        exclude:
          - arch: aarch64_cortex-a76
            branch: openwrt-23.05

    steps:
      - name: Checkout source code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup build environment
        run: |
          sudo apt-get update
          sudo apt-get install -y build-essential libncurses5-dev zlib1g-dev gawk git gettext libssl-dev xsltproc wget unzip python3

      - name: Build packages with OpenWRT SDK
        uses: openwrt/gh-action-sdk@main
        env:
          ARCH: ${{ matrix.arch }}
          BRANCH: ${{ matrix.branch }}
          FEEDNAME: custom_packages
          FEED_DIR: ./packages/
          INDEX: 1
          NO_REFRESH_CHECK: true
          IGNORE_ERRORS: true

      - name: Verify build artifacts
        run: |
          if [ ! -d "bin/packages/${{ matrix.arch }}/custom_packages" ]; then
            echo "::warning::No packages were built for ${{ matrix.arch }} (${{ matrix.branch }})"
            exit 0
          fi

      - name: Organize packages
        run: |
          # Create structured output directory
          OUTPUT_DIR="releases/${{ matrix.branch }}/${{ matrix.arch }}"
          mkdir -p "$OUTPUT_DIR"
          
          # Copy packages with verification
          if [ -d "bin/packages/${{ matrix.arch }}/custom_packages" ]; then
            rsync -av --ignore-missing-args \
              "bin/packages/${{ matrix.arch }}/custom_packages/" \
              "$OUTPUT_DIR/"
          fi
          
          # Generate simple manifest
          {
            echo "# Package Manifest"
            echo "Architecture: ${{ matrix.arch }}"
            echo "OpenWRT Version: ${{ matrix.branch }}"
            echo "Build Date: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
            echo ""
            echo "## Packages"
            find "$OUTPUT_DIR" -type f -name '*.ipk' -o -name '*.apk' | sort | sed 's|.*/||'
          } > "$OUTPUT_DIR/MANIFEST.md"

      - name: Create compressed archive
        run: |
          tar -czf "packages_${{ matrix.arch }}-${{ matrix.branch }}.tar.gz" \
            -C "releases/${{ matrix.branch }}/${{ matrix.arch }}" .

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: packages_${{ matrix.arch }}-${{ matrix.branch }}
          path: |
            releases/${{ matrix.branch }}/${{ matrix.arch }}/*
            packages_${{ matrix.arch }}-${{ matrix.branch }}.tar.gz

  release:
    name: Publish Packages
    needs: build
    runs-on: ubuntu-latest
    if: always() && (needs.build.result == 'success' || needs.build.result == 'failure')

    steps:
      - name: Checkout releases branch
        uses: actions/checkout@v4
        with:
          ref: releases
          fetch-depth: 1
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Git LFS and configure Git
        run: |
          git lfs install
          git config --global user.email "actions@github.com"
          git config --global user.name "OpenWRT Package Builder"
          git config --global pull.rebase true
          git config --global core.compression 9
          git config --global pack.compression 9

      - name: Create .gitattributes for binary files
        run: |
          cat > .gitattributes <<EOF
          *.ipk filter=lfs diff=lfs merge=lfs -text
          *.apk filter=lfs diff=lfs merge=lfs -text
          *.tar.gz filter=lfs diff=lfs merge=lfs -text
          *.tgz filter=lfs diff=lfs merge=lfs -text
          packages/** linguist-generated=true
          EOF

      - name: Download and verify artifacts
        run: |
          set -e
          
          RUN_ID="${{ github.event.workflow_run.id }}"
          echo "üì• Downloading artifacts from run ID: $RUN_ID"
          
          # Create artifacts directory
          mkdir -p ./artifacts
          
          # Check if run exists and has artifacts
          if ! gh api "repos/$SOURCE_REPO/actions/runs/$RUN_ID" > /dev/null 2>&1; then
            echo "‚ùå Run ID $RUN_ID not found or not accessible"
            exit 1
          fi
          
          # List available artifacts
          echo "üìã Available artifacts:"
          gh api "repos/$SOURCE_REPO/actions/runs/$RUN_ID/artifacts" --jq '.artifacts[] | "\(.name) (\(.size_in_bytes) bytes)"'
          
          # Download artifacts with retry logic
          max_retries=3
          for i in $(seq 1 $max_retries); do
            if gh run download "$RUN_ID" --repo "$SOURCE_REPO" --dir ./artifacts; then
              echo "‚úÖ Artifacts downloaded successfully on attempt $i"
              break
            else
              echo "‚ö†Ô∏è Download attempt $i failed"
              if [ $i -eq $max_retries ]; then
                echo "‚ùå All download attempts failed"
                exit 1
              fi
              sleep 10
            fi
          done
          
          # Verify download
          if [ ! -d "./artifacts" ] || [ -z "$(ls -A ./artifacts)" ]; then
            echo "‚ùå No artifacts downloaded"
            exit 1
          fi
          
          echo "üì¶ Downloaded artifacts:"
          find ./artifacts -type f -name "*.ipk" -o -name "*.apk" | wc -l | xargs echo "Total packages:"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Process and organize packages
        run: |
          set -e
          
          echo "üîÑ Processing artifacts..."
          
          # Create base directory
          mkdir -p packages
          
          # Track statistics
          total_processed=0
          failed_artifacts=0
          
          # Process each artifact directory
          for artifact_dir in artifacts/packages_*; do
            if [ ! -d "$artifact_dir" ]; then
              continue
            fi
            
            # Extract metadata from artifact name
            artifact_name=$(basename "$artifact_dir")
            echo "üìÅ Processing artifact: $artifact_name"
            
            # Parse artifact name (format: packages_ARCH_BRANCH or packages_ARCH-BRANCH)
            metadata=${artifact_name#packages_}
            
            # Try different parsing strategies
            if [[ "$metadata" == *"-"* ]]; then
              arch=${metadata%-*}
              branch=${metadata##*-}
            elif [[ "$metadata" == *"_"* ]]; then
              arch=${metadata%_*}
              branch=${metadata##*_}
            else
              echo "‚ö†Ô∏è Could not parse artifact name: $artifact_name, skipping"
              failed_artifacts=$((failed_artifacts + 1))
              continue
            fi
            
            echo "  Architecture: $arch"
            echo "  Branch: $branch"
            
            # Create target directory
            target_dir="packages/$branch/$arch"
            mkdir -p "$target_dir"
            
            # Find and copy packages with multiple search patterns
            package_copied=false
            for search_path in \
              "$artifact_dir/releases/$branch/$arch" \
              "$artifact_dir/$branch/$arch" \
              "$artifact_dir/packages/$branch/$arch" \
              "$artifact_dir"; do
              
              if [ -d "$search_path" ]; then
                echo "  Found packages in: $search_path"
                
                # Copy packages efficiently
                package_files=$(find "$search_path" -name "*.ipk" -o -name "*.apk" 2>/dev/null || true)
                if [ -n "$package_files" ]; then
                  echo "$package_files" | while IFS= read -r package; do
                    if [ -f "$package" ]; then
                      cp "$package" "$target_dir/" 2>/dev/null || echo "    ‚ö†Ô∏è Failed to copy: $(basename "$package")"
                    fi
                  done
                  package_copied=true
                fi
                break
              fi
            done
            
            # Verify packages were copied
            actual_count=$(find "$target_dir" -name "*.ipk" -o -name "*.apk" 2>/dev/null | wc -l)
            if [ "$actual_count" -eq 0 ]; then
              echo "  ‚ö†Ô∏è No packages found for $arch/$branch"
              rmdir "$target_dir" 2>/dev/null || true
              rmdir "packages/$branch" 2>/dev/null || true
            else
              echo "  ‚úÖ Processed $actual_count packages for $arch/$branch"
              total_processed=$((total_processed + actual_count))
            fi
          done
          
          echo "üìä Processing complete:"
          echo "  Total packages processed: $total_processed"
          echo "  Failed artifacts: $failed_artifacts"
          
          if [ $total_processed -eq 0 ]; then
            echo "‚ùå No packages were processed successfully"
            exit 1
          fi

      - name: Repository size management
        run: |
          set -e
          
          # Calculate current repository size
          repo_size_mb=$(du -sm . | cut -f1)
          echo "üìè Current repository size: ${repo_size_mb}MB"
          
          if [ $repo_size_mb -gt $MAX_REPO_SIZE_MB ] || [ "${{ github.event.inputs.force_cleanup }}" = "true" ]; then
            echo "üßπ Repository cleanup required (size: ${repo_size_mb}MB, limit: ${MAX_REPO_SIZE_MB}MB)"
            
            # Strategy 1: Remove oldest packages by modification time
            echo "  Removing oldest packages..."
            find packages -name "*.ipk" -o -name "*.apk" | \
              xargs ls -lt | \
              tail -n +$(( MAX_REPO_SIZE_MB * 10 )) | \
              awk '{print $NF}' | \
              xargs rm -f 2>/dev/null || true
            
            # Strategy 2: Keep only latest packages per architecture
            echo "  Deduplicating packages..."
            for arch_dir in packages/*/*; do
              if [ -d "$arch_dir" ]; then
                # Keep only the latest version of each package
                find "$arch_dir" -name "*.ipk" -o -name "*.apk" | \
                  sed 's/_[^_]*\.ipk$//' | \
                  sort | uniq -d | \
                  while read -r base_name; do
                    find "$arch_dir" -name "${base_name}_*.ipk" -o -name "${base_name}_*.apk" | \
                      head -n -1 | \
                      xargs rm -f
                  done
              fi
            done
            
            # Remove empty directories
            find packages -type d -empty -delete 2>/dev/null || true
            
            new_size_mb=$(du -sm . | cut -f1)
            echo "  üìâ Repository size after cleanup: ${new_size_mb}MB"
          fi

      - name: Generate repository metadata
        run: |
          set -e
          
          echo "üìã Generating repository metadata..."
          
          # Calculate statistics
          total_packages=$(find packages -name "*.ipk" -o -name "*.apk" 2>/dev/null | wc -l)
          total_branches=$(find packages -mindepth 1 -maxdepth 1 -type d 2>/dev/null | wc -l)
          total_archs=$(find packages -mindepth 2 -maxdepth 2 -type d 2>/dev/null | wc -l)
          repo_size_mb=$(du -sm packages 2>/dev/null | cut -f1)
          
          # Create repository metadata JSON
          cat > packages/repository.json <<EOF
          {
            "repository": {
              "name": "OpenWRT Custom Packages",
              "version": "1.0",
              "updated": "$(date -u '+%Y-%m-%dT%H:%M:%SZ')",
              "statistics": {
                "total_packages": $total_packages,
                "total_branches": $total_branches,
                "total_architectures": $total_archs,
                "repository_size_mb": $repo_size_mb
              },
              "branches": $(find packages -mindepth 1 -maxdepth 1 -type d -exec basename {} \; | jq -R . | jq -s .),
              "workflow": {
                "run_id": "${{ github.run_id }}",
                "source_repo": "$SOURCE_REPO"
              }
            }
          }
          EOF
          
          # Generate comprehensive README
          {
            cat <<'EOF'
          # üì¶ OpenWRT Custom Packages Repository
          
          This repository contains pre-built packages for various OpenWRT versions and architectures.
          
          ## üìä Repository Statistics
          EOF
            echo "- **Last updated**: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
            echo "- **Total packages**: $total_packages"
            echo "- **Repository size**: ${repo_size_mb}MB"
            echo "- **Supported branches**: $total_branches"
            echo "- **Supported architectures**: $total_archs"
            echo ""
            echo "## üèóÔ∏è Supported OpenWRT Versions"
            echo ""
            
            for branch_dir in packages/*; do
              if [ -d "$branch_dir" ]; then
                branch_name=$(basename "$branch_dir")
                branch_packages=$(find "$branch_dir" -name "*.ipk" -o -name "*.apk" | wc -l)
                branch_archs=$(find "$branch_dir" -mindepth 1 -maxdepth 1 -type d | wc -l)
                echo "### üîß $branch_name"
                echo "- **Packages**: $branch_packages"
                echo "- **Architectures**: $branch_archs"
                echo ""
                
                for arch_dir in "$branch_dir"/*; do
                  if [ -d "$arch_dir" ]; then
                    arch_name=$(basename "$arch_dir")
                    arch_packages=$(find "$arch_dir" -name "*.ipk" -o -name "*.apk" | wc -l)
                    if [ $arch_packages -gt 0 ]; then
                      echo "  - **$arch_name**: $arch_packages packages"
                    fi
                  fi
                done
                echo ""
              fi
            done
            
            cat <<EOF
          
          ## üöÄ Usage
          
          ### Adding Repository to OpenWRT
          
          \`\`\`bash
          # Add custom repository
          echo "src/gz custom_packages https://raw.githubusercontent.com/${{ github.repository }}/releases/packages/[BRANCH]/[ARCH]" >> /etc/opkg/customfeeds.conf
          
          # Update package lists
          opkg update
          
          # Install packages
          opkg install [package_name]
          \`\`\`
          
          ### Direct Download
          
          Browse and download packages directly from:
          - üåê [GitHub Releases](https://github.com/${{ github.repository }}/tree/releases/packages)
          - üìã [Package Index](packages/repository.json)
          
          ## üîÑ Build Information
          
          - **Source Repository**: [$SOURCE_REPO](https://github.com/$SOURCE_REPO)
          - **Workflow Run**: [${{ github.run_id }}](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})
          - **Build Date**: $(date -u '+%Y-%m-%d %H:%M:%S UTC')
          
          ---
          
          *This repository is automatically updated via GitHub Actions*
          EOF
          } > README.md
          
          echo "‚úÖ Metadata generated:"
          echo "  Packages: $total_packages"
          echo "  Branches: $total_branches"
          echo "  Architectures: $total_archs"

      - name: Commit and push changes efficiently
        run: |
          set -e
          
          echo "üîÑ Committing changes..."
          
          # Check if there are any changes to commit
          if git diff --quiet && git diff --cached --quiet; then
            echo "‚ÑπÔ∏è No changes to commit"
            exit 0
          fi
          
          # Stage metadata files first
          git add .gitattributes packages/repository.json README.md 2>/dev/null || true
          
          # Commit metadata if there are changes
          if ! git diff --cached --quiet; then
            git commit -m "üìù Update repository metadata" \
                      -m "Updated: $(date -u '+%Y-%m-%d %H:%M:%S UTC')" \
                      -m "Packages: $(find packages -name '*.ipk' -o -name '*.apk' | wc -l)" \
                      -m "Source: $SOURCE_REPO"
          fi
          
          # Process packages by architecture in batches
          total_packages=$(find packages -name "*.ipk" -o -name "*.apk" | wc -l)
          
          if [ $total_packages -gt 0 ]; then
            echo "üì§ Processing $total_packages packages for commit..."
            
            # Use Git LFS for package files
            git lfs track "*.ipk" "*.apk"
            git add .gitattributes
            
            # Commit packages by architecture to keep commits manageable
            for branch_dir in packages/*; do
              if [ -d "$branch_dir" ]; then
                branch=$(basename "$branch_dir")
                
                for arch_dir in "$branch_dir"/*; do
                  if [ -d "$arch_dir" ]; then
                    arch=$(basename "$arch_dir")
                    arch_packages=$(find "$arch_dir" -name "*.ipk" -o -name "*.apk" | wc -l)
                    
                    if [ $arch_packages -gt 0 ]; then
                      echo "  üì¶ Adding $arch_packages packages for $branch/$arch"
                      
                      # Add packages in smaller batches if too many
                      if [ $arch_packages -gt $BATCH_SIZE ]; then
                        find "$arch_dir" -name "*.ipk" -o -name "*.apk" | \
                          split -l $BATCH_SIZE - /tmp/batch_
                        
                        batch_num=1
                        for batch_file in /tmp/batch_*; do
                          if [ -f "$batch_file" ]; then
                            echo "    Batch $batch_num ($(wc -l < "$batch_file") packages)"
                            xargs git add < "$batch_file"
                            
                            if ! git diff --cached --quiet; then
                              git commit -m "üì¶ Add $branch/$arch packages (batch $batch_num)" \
                                        -m "Architecture: $arch" \
                                        -m "Branch: $branch" \
                                        -m "Batch: $batch_num/$(ls /tmp/batch_* | wc -l)"
                            fi
                            
                            rm "$batch_file"
                            ((batch_num++))
                          fi
                        done
                      else
                        git add "$arch_dir"
                        
                        if ! git diff --cached --quiet; then
                          git commit -m "üì¶ Add $branch/$arch packages" \
                                    -m "Architecture: $arch" \
                                    -m "Branch: $branch" \
                                    -m "Packages: $arch_packages"
                        fi
                      fi
                    fi
                  fi
                done
              fi
            done
          fi
          
          echo "üöÄ Pushing changes to releases branch..."
          
          # Push with retry logic
          max_retries=3
          for i in $(seq 1 $max_retries); do
            if git push origin releases; then
              echo "‚úÖ Successfully pushed on attempt $i"
              break
            else
              echo "‚ö†Ô∏è Push attempt $i failed"
              if [ $i -eq $max_retries ]; then
                echo "‚ùå All push attempts failed"
                exit 1
              fi
              
              echo "  Retrying in 30 seconds..."
              sleep 30
              
              # Try to resolve conflicts
              git pull --rebase origin releases || true
            fi
          done
          
          echo "üéâ Package release completed successfully!"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}